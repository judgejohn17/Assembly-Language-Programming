


ARM Macro Assembler    Page 1 


    1 00000000         
    2 00000000         ;****************************************************************
    3 00000000         ;Descriptive comment header goes here.
    4 00000000         ;This program develops a time for the KL46 periodic interrupt
    5 00000000         ;timer 
    6 00000000         ;Name:  John Judge
    7 00000000         ;Date: 4/21/16
    8 00000000         ;Class:  CMPE-250
    9 00000000         ;Section: Thursdays 2:00pm-3:50pm
   10 00000000         ;---------------------------------------------------------------
   11 00000000         ;Keil Template for KL46
   12 00000000         ;R. W. Melton
   13 00000000         ;April 3, 2015
   14 00000000         ;****************************************************************
   15 00000000         ;Assembler directives
   16 00000000                 THUMB
   18 00000000         ;****************************************************************
   19 00000000         ;Include files
   20 00000000                 GET              MKL46Z4.s   ;Included by start.s
   22 00000000         ;****************************************************************
   23 00000000         ;EQUates
   24 00000000         ;PORTx_PCRn (Port x pin control register n [for pin n])
   25 00000000         ;___->10-08:Pin mux control (select 0 to 8)
   26 00000000         ;Use provided PORT_PCR_MUX_SELECT_2_MASK
   27 00000000         ;---------------------------------------------------------------
   28 00000000         ;Port A
   30 00000000 01000200 
                       PORT_PCR_SET_PTA1_UART0_RX
                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   32 00000000 01000200 
                       PORT_PCR_SET_PTA2_UART0_TX
                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   33 00000000         ;---------------------------------------------------------------
   34 00000000         ;SIM_SCGC4
   35 00000000         ;1->10:UART0 clock gate control (enabled)
   36 00000000         ;Use provided SIM_SCGC4_UART0_MASK
   37 00000000         ;---------------------------------------------------------------
   38 00000000         ;SIM_SCGC5
   39 00000000         ;1->09:Port A clock gate control (enabled)
   40 00000000         ;Use provided SIM_SCGC5_PORTA_MASK



ARM Macro Assembler    Page 2 


   41 00000000         ;---------------------------------------------------------------
   42 00000000         ;SIM_SOPT2
   43 00000000         ;01=27-26:UART0SRC=UART0 clock source select
   44 00000000         ;         (PLLFLLSEL determines MCGFLLCLK' or MCGPLLCLK/2)
   45 00000000         ; 1=   16:PLLFLLSEL=PLL/FLL clock select (MCGPLLCLK/2)
   47 00000000 04000000 
                       SIM_SOPT2_UART0SRC_MCGPLLCLK
                               EQU              (1 << SIM_SOPT2_UART0SRC_SHIFT)
   49 00000000 04010000 
                       SIM_SOPT2_UART0_MCGPLLCLK_DIV2
                               EQU              (SIM_SOPT2_UART0SRC_MCGPLLCLK :OR: SIM_SOPT2_PLLFLLSEL_MASK)
   50 00000000         ;---------------------------------------------------------------
   51 00000000         ;SIM_SOPT5
   52 00000000         ; 0->   16:UART0 open drain enable (disabled)
   53 00000000         ; 0->   02:UART0 receive data select (UART0_RX)
   54 00000000         ;00->01-00:UART0 transmit data select source (UART0_TX)
   58 00000000 00010007 
                       SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
                               EQU              (SIM_SOPT5_UART0ODE_MASK :OR:                                  SIM_SOPT
5_UART0RXSRC_MASK :OR:                                  SIM_SOPT5_UART0TXSRC_MASK)
   59 00000000         ;---------------------------------------------------------------
   60 00000000         ;UART0_BDH
   61 00000000         ;    0->  7:LIN break detect IE (disabled)
   62 00000000         ;    0->  6:RxD input active edge IE (disabled)
   63 00000000         ;    0->  5:Stop bit number select (1)
   64 00000000         ;00001->4-0:SBR[12:0] (UART0CLK / [9600 * (OSR + 1)]) 
   65 00000000         ;UART0CLK is MCGPLLCLK/2
   66 00000000         ;MCGPLLCLK is 96 MHz
   67 00000000         ;MCGPLLCLK/2 is 48 MHz
   68 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   69 00000000 00000001 
                       UART0_BDH_9600
                               EQU              0x01
   70 00000000         ;---------------------------------------------------------------
   71 00000000         ;UART0_BDL
   72 00000000         ;26->7-0:SBR[7:0] (UART0CLK / [9600 * (OSR + 1)])
   73 00000000         ;UART0CLK is MCGPLLCLK/2
   74 00000000         ;MCGPLLCLK is 96 MHz
   75 00000000         ;MCGPLLCLK/2 is 48 MHz
   76 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   77 00000000 00000038 
                       UART0_BDL_9600



ARM Macro Assembler    Page 3 


                               EQU              0x38
   78 00000000         ;---------------------------------------------------------------
   79 00000000         ;UART0_C1
   80 00000000         ;0-->7:LOOPS=loops select (normal)
   81 00000000         ;0-->6:DOZEEN=doze enable (disabled)
   82 00000000         ;0-->5:RSRC=receiver source select (internal--no effect LOOPS=0)
   83 00000000         ;0-->4:M=9- or 8-bit mode select 
   84 00000000         ;        (1 start, 8 data [lsb first], 1 stop)
   85 00000000         ;0-->3:WAKE=receiver wakeup method select (idle)
   86 00000000         ;0-->2:IDLE=idle line type select (idle begins after start bit)
   87 00000000         ;0-->1:PE=parity enable (disabled)
   88 00000000         ;0-->0:PT=parity type (even parity--no effect PE=0)
   89 00000000 00000000 
                       UART0_C1_8N1
                               EQU              0x00
   90 00000000         ;---------------------------------------------------------------
   91 00000000         ;UART0_C2
   92 00000000         ;0-->7:TIE=transmit IE for TDRE (disabled)
   93 00000000         ;0-->6:TCIE=transmission complete IE for TC (disabled)
   94 00000000         ;0-->5:RIE=receiver IE for RDRF (disabled)
   95 00000000         ;0-->4:ILIE=idle line IE for IDLE (disabled)
   96 00000000         ;1-->3:TE=transmitter enable (enabled)
   97 00000000         ;1-->2:RE=receiver enable (enabled)
   98 00000000         ;0-->1:RWU=receiver wakeup control (normal)
   99 00000000         ;0-->0:SBK=send break (disabled, normal)
  100 00000000 0000000C 
                       UART0_C2_T_R
                               EQU              (UART0_C2_TE_MASK :OR: UART0_C2_RE_MASK)
  101 00000000 0000002C 
                       UART0_C2_T_RI
                               EQU              (UART0_C2_RIE_MASK :OR: UART0_C2_T_R)
  102 00000000 000000AC 
                       UART0_C2_TI_RI
                               EQU              (UART0_C2_TIE_MASK :OR: UART0_C2_T_RI)
  103 00000000         ;---------------------------------------------------------------
  104 00000000         ;UART0_C3
  105 00000000         ;0-->7:R8T9=9th data bit for receiver (not used M=0)
  106 00000000         ;           10th data bit for transmitter (not used M10=0)
  107 00000000         ;0-->6:R9T8=9th data bit for transmitter (not used M=0)
  108 00000000         ;           10th data bit for receiver (not used M10=0)
  109 00000000         ;0-->5:TXDIR=UART_TX pin direction in single-wire mode
  110 00000000         ;            (no effect LOOPS=0)



ARM Macro Assembler    Page 4 


  111 00000000         ;0-->4:TXINV=transmit data inversion (not inverted)
  112 00000000         ;0-->3:ORIE=overrun IE for OR (disabled)
  113 00000000         ;0-->2:NEIE=noise error IE for NF (disabled)
  114 00000000         ;0-->1:FEIE=framing error IE for FE (disabled)
  115 00000000         ;0-->0:PEIE=parity error IE for PF (disabled)
  116 00000000 00000000 
                       UART0_C3_NO_TXINV
                               EQU              0x00
  117 00000000         ;---------------------------------------------------------------
  118 00000000         ;UART0_C4
  119 00000000         ;    0-->  7:MAEN1=match address mode enable 1 (disabled)
  120 00000000         ;    0-->  6:MAEN2=match address mode enable 2 (disabled)
  121 00000000         ;    0-->  5:M10=10-bit mode select (not selected)
  122 00000000         ;01111-->4-0:OSR=over sampling ratio (16)
  123 00000000         ;               = 1 + OSR for 3 <= OSR <= 31
  124 00000000         ;               = 16 for 0 <= OSR <= 2 (invalid values)
  125 00000000 0000000F 
                       UART0_C4_OSR_16
                               EQU              0x0F
  126 00000000 0000000F 
                       UART0_C4_NO_MATCH_OSR_16
                               EQU              UART0_C4_OSR_16
  127 00000000         ;---------------------------------------------------------------
  128 00000000         ;UART0_C5
  129 00000000         ;  0-->  7:TDMAE=transmitter DMA enable (disabled)
  130 00000000         ;  0-->  6:Reserved; read-only; always 0
  131 00000000         ;  0-->  5:RDMAE=receiver full DMA enable (disabled)
  132 00000000         ;000-->4-2:Reserved; read-only; always 0
  133 00000000         ;  0-->  1:BOTHEDGE=both edge sampling (rising edge only)
  134 00000000         ;  0-->  0:RESYNCDIS=resynchronization disable (enabled)
  135 00000000 00000000 
                       UART0_C5_NO_DMA_SSR_SYNC
                               EQU              0x00
  136 00000000         ;---------------------------------------------------------------
  137 00000000         ;UART0_S1
  138 00000000         ;0-->7:TDRE=transmit data register empty flag; read-only
  139 00000000         ;0-->6:TC=transmission complete flag; read-only
  140 00000000         ;0-->5:RDRF=receive data register full flag; read-only
  141 00000000         ;1-->4:IDLE=idle line flag; write 1 to clear (clear)
  142 00000000         ;1-->3:OR=receiver overrun flag; write 1 to clear (clear)
  143 00000000         ;1-->2:NF=noise flag; write 1 to clear (clear)
  144 00000000         ;1-->1:FE=framing error flag; write 1 to clear (clear)



ARM Macro Assembler    Page 5 


  145 00000000         ;1-->0:PF=parity error flag; write 1 to clear (clear)
  146 00000000 0000001F 
                       UART0_S1_CLEAR_FLAGS
                               EQU              0x1F
  147 00000000         ;---------------------------------------------------------------
  148 00000000         ;UART0_S2
  149 00000000         ;1-->7:LBKDIF=LIN break detect interrupt flag (clear)
  150 00000000         ;             write 1 to clear
  151 00000000         ;1-->6:RXEDGIF=RxD pin active edge interrupt flag (clear)
  152 00000000         ;              write 1 to clear
  153 00000000         ;0-->5:(reserved); read-only; always 0
  154 00000000         ;0-->4:RXINV=receive data inversion (disabled)
  155 00000000         ;0-->3:RWUID=receive wake-up idle detect
  156 00000000         ;0-->2:BRK13=break character generation length (10)
  157 00000000         ;0-->1:LBKDE=LIN break detect enable (disabled)
  158 00000000         ;0-->0:RAF=receiver active flag; read-only
  159 00000000 000000C0 
                       UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
                               EQU              0xC0
  160 00000000         ;---------------------------------------------------------------
  161 00000000         ;---------------------------------------------------------------
  162 00000000         ;NVIC_ICER
  163 00000000         ;31-00:CLRENA=masks for HW IRQ sources;
  164 00000000         ;             read:   0 = unmasked;   1 = masked
  165 00000000         ;             write:  0 = no effect;  1 = mask
  166 00000000         ;22:PIT IRQ mask
  167 00000000         ;12:UART0 IRQ mask
  168 00000000 00400000 
                       NVIC_ICER_PIT_MASK
                               EQU              PIT_IRQ_MASK
  169 00000000 00001000 
                       NVIC_ICER_UART0_MASK
                               EQU              UART0_IRQ_MASK
  170 00000000         ;---------------------------------------------------------------
  171 00000000         ;NVIC_ICPR
  172 00000000         ;31-00:CLRPEND=pending status for HW IRQ sources;
  173 00000000         ;             read:   0 = not pending;  1 = pending
  174 00000000         ;             write:  0 = no effect;
  175 00000000         ;                     1 = change status to not pending
  176 00000000         ;22:PIT IRQ pending status
  177 00000000         ;12:UART0 IRQ pending status
  178 00000000 00400000 



ARM Macro Assembler    Page 6 


                       NVIC_ICPR_PIT_MASK
                               EQU              PIT_IRQ_MASK
  179 00000000 00001000 
                       NVIC_ICPR_UART0_MASK
                               EQU              UART0_IRQ_MASK
  180 00000000         ;---------------------------------------------------------------
  181 00000000         ;NVIC_IPR0-NVIC_IPR7
  182 00000000         ;2-bit priority:  00 = highest; 11 = lowest
  183 00000000         ;--PIT
  184 00000000 00000000 
                       PIT_IRQ_PRIORITY
                               EQU              0
  185 00000000 00C00000 
                       NVIC_IPR_PIT_MASK
                               EQU              (3 << PIT_PRI_POS)
  186 00000000 00000000 
                       NVIC_IPR_PIT_PRI_0
                               EQU              (PIT_IRQ_PRIORITY << UART0_PRI_POS)
  187 00000000         ;--UART0
  188 00000000 00000003 
                       UART0_IRQ_PRIORITY
                               EQU              3
  189 00000000 000000C0 
                       NVIC_IPR_UART0_MASK
                               EQU              (3 << UART0_PRI_POS)
  190 00000000 000000C0 
                       NVIC_IPR_UART0_PRI_3
                               EQU              (UART0_IRQ_PRIORITY << UART0_PRI_POS)
  191 00000000         ;---------------------------------------------------------------
  192 00000000         ;NVIC_ISER
  193 00000000         ;31-00:SETENA=masks for HW IRQ sources;
  194 00000000         ;             read:   0 = masked;     1 = unmasked
  195 00000000         ;             write:  0 = no effect;  1 = unmask
  196 00000000         ;22:PIT IRQ mask
  197 00000000         ;12:UART0 IRQ mask
  198 00000000 00400000 
                       NVIC_ISER_PIT_MASK
                               EQU              PIT_IRQ_MASK
  199 00000000 00001000 
                       NVIC_ISER_UART0_MASK
                               EQU              UART0_IRQ_MASK
  200 00000000         ;---------------------------------------------------------------



ARM Macro Assembler    Page 7 


  201 00000000         ;PIT_LDVALn:  PIT load value register n
  202 00000000         ;31-00:TSV=timer start value (period in clock cycles - 1)
  203 00000000         ;Clock ticks for 0.01 s at 24 MHz count rate
  204 00000000         ;0.01 s * 24,000,000 Hz = 240,000
  205 00000000         ;TSV = 240,000 - 1
  206 00000000 0003A97F 
                       PIT_LDVAL_10ms
                               EQU              239999
  207 00000000         ;---------------------------------------------------------------
  208 00000000         ;PIT_MCR:  PIT module control register
  209 00000000         ;1-->    0:FRZ=freeze (continue'/stop in debug mode)
  210 00000000         ;0-->    1:MDIS=module disable (PIT section)
  211 00000000         ;               RTI timer not affected
  212 00000000         ;               must be enabled before any other PIT setup
  213 00000000 00000001 
                       PIT_MCR_EN_FRZ
                               EQU              PIT_MCR_FRZ_MASK
  214 00000000         ;---------------------------------------------------------------
  215 00000000         ;PIT_TCTRLn:  PIT timer control register n
  216 00000000         ;0-->   2:CHN=chain mode (enable)
  217 00000000         ;1-->   1:TIE=timer interrupt enable
  218 00000000         ;1-->   0:TEN=timer enable
  219 00000000 00000003 
                       PIT_TCTRL_CH_IE
                               EQU              (PIT_TCTRL_TEN_MASK :OR: PIT_TCTRL_TIE_MASK)
  220 00000000         ;---------------------------------------------------------------
  221 00000000         ;Interrupt should be set to the highest priority
  222 00000000 00000000 
                       PIT_IRQ_PRI
                               EQU              0
  223 00000000         ;---------------------------------------------------
  224 00000000         
  225 00000000         ;Max length of queue
  226 00000000 00000004 
                       Q_BUF_SZ
                               EQU              4
  227 00000000 00000012 
                       Q_REC_SZ
                               EQU              18
  228 00000000         
  229 00000000         ;Max length of prompt string
  230 00000000 0000004F 



ARM Macro Assembler    Page 8 


                       MAX_STRING
                               EQU              79
  231 00000000 00000050 
                       MAX_QUEUE
                               EQU              80
  232 00000000 00000000 
                       IN_PTR  EQU              0
  233 00000000 00000004 
                       OUT_PTR EQU              4
  234 00000000 00000008 
                       BUF_START
                               EQU              8
  235 00000000 0000000C 
                       BUF_PAST
                               EQU              12
  236 00000000 00000010 
                       BUF_SIZE
                               EQU              16
  237 00000000 00000011 
                       NUM_ENQD
                               EQU              17
  238 00000000         
  239 00000000 000001F4 
                       FiveSec EQU              500
  240 00000000         ;****************************************************************
  241 00000000         ;Program
  242 00000000         ;Linker requires Reset_Handler
  243 00000000                 AREA             MyCode,CODE,READONLY
  244 00000000                 ENTRY
  245 00000000                 EXPORT           Reset_Handler
  246 00000000                 IMPORT           Startup
  247 00000000         Reset_Handler
  248 00000000         main
  249 00000000         ;---------------------------------------------------------------
  250 00000000         ;Mask interrupts
  251 00000000 B672            CPSID            I
  252 00000002         ;KL46 system startup with 48-MHz system clock
  253 00000002 F7FF FFFE       BL               Startup
  254 00000006         ;---------------------------------------------------------------
  255 00000006         ;>>>>> begin main program code <<<<<
  256 00000006         
  257 00000006         ;Enable clock interrupts



ARM Macro Assembler    Page 9 


  258 00000006 F000 F9A4       BL               Init_UART0_IRQ
  259 0000000A F000 F9EF       BL               Init_PIT_IRQ
  260 0000000E         Main
  261 0000000E 4833            LDR              R0,=RunStopWatch ;Initialize The Stop Watch 
  262 00000010 2100            MOVS             R1,#0       ;
  263 00000012 7001            STRB             R1,[R0,#0]  ;Initialize StopWatch to zero
  264 00000014 4832            LDR              R0,=Count   ;Initialize count 
  265 00000016 2100            MOVS             R1,#0       ;
  266 00000018 7001            STRB             R1,[R0,#0]  ;Initialize count as zero 
  267 0000001A 4832            LDR              R0,=AccessCodePrompt ;prompt to print
  268 0000001C F000 F956       BL               LengthStringSB ;Find length for PutStringSB
  269 00000020 F000 F948       BL               PutStringSB ;Print prompt
  270 00000024 200D            MOVS             R0,#0x0D    ;Line feed
  271 00000026 F000 F91B       BL               PutChar
  272 0000002A 200A            MOVS             R0,#0x0A    ;Carriage return 
  273 0000002C F000 F918       BL               PutChar
  274 00000030 203E            MOVS             R0,#">"     ;Input carrot
  275 00000032 F000 F915       BL               PutChar
  276 00000036 4829            LDR              R0,=RunStopWatch ;Change stop watch value
  277 00000038 2101            MOVS             R1,#1
  278 0000003A 7001            STRB             R1,[R0, #0] ;Store RunStopWatch=1
  279 0000003C 214F            MOVS             R1,#MAX_STRING ;Initialize Max_string for GetStringSb
  280 0000003E 482A            LDR              R0,=InputString ;Initialize input string
  281 00000040 F000 F921       BL               GetStringSB ;Poll for new String
  282 00000044 4825            LDR              R0,=RunStopWatch ;Initialize stopwatch to set to 0
  283 00000046 2100            MOVS             R1,#0
  284 00000048 7001            STRB             R1,[R0, #0] ;Set RunStopWatch = 0
  285 0000004A 200D            MOVS             R0,#0x0D    ;Carriage Return
  286 0000004C F000 F908       BL               PutChar
  287 00000050 200A            MOVS             R0,#0x0A    ;Line Feed
  288 00000052 F000 F905       BL               PutChar
  289 00000056 203C            MOVS             R0,#'<'     ;Carrot
  290 00000058 F000 F902       BL               PutChar
  291 0000005C 4820            LDR              R0,=Count   ;Load count
  292 0000005E 6800            LDR              R0,[R0,#0]
  293 00000060 0001            MOVS             R1,R0       ;Move to R1 for PutNumU
  294 00000062 F000 F961       BL               PutNumU     ;Print Count number
  295 00000066 4821            LDR              R0,=TimeString ;String to add to end of time
  296 00000068 F000 F930       BL               LengthStringSB ;Find length for PutStringSB
  297 0000006C F000 F922       BL               PutStringSB
  298 00000070 200D            MOVS             R0,#0x0D    ;Carriage Return
  299 00000072 F000 F8F5       BL               PutChar     ;



ARM Macro Assembler    Page 10 


  300 00000076 200A            MOVS             R0,#0x0A    ;Line Feed
  301 00000078 F000 F8F2       BL               PutChar
  302 0000007C 200A            MOVS             R0,#10      ;Divide the count by 10
  303 0000007E F000 F933       BL               DIVU
  304 00000082 4F1E            LDR              R7,=FiveSec
  305 00000084 42B8            CMP              R0,R7       ;Compare to 5 seconds
  306 00000086 DA1B            BGE              AccessDenied ;If it took longer than 5 seconds
  307 00000088 4817            LDR              R0,=InputString ;Load input string
  308 0000008A 4919            LDR              R1,=AccessCode ;Load code 
  309 0000008C 2207            MOVS             R2,#7       ;Length of code
  310 0000008E         CheckChar
  311 0000008E 5C83            LDRB             R3,[R0,R2]  ;Load input string
  312 00000090 5C8C            LDRB             R4,[R1,R2]  ;Load code string
  313 00000092 42A3            CMP              R3,R4       ;Compare strings
  314 00000094 D114            BNE              AccessDenied ;If strings are not equal
  315 00000096 2A00            CMP              R2,#0       ;Check to make sur all characters have been checked 
  316 00000098 D001            BEQ              AccessGranted ;If equal then allow access
  317 0000009A 1E52            SUBS             R2,R2,#1    ;Decrement amount and keep looping
  318 0000009C E7F7            B                CheckChar
  319 0000009E         AccessGranted
  320 0000009E 4815            LDR              R0,=Granted ;Access granted string
  321 000000A0 F000 F914       BL               LengthStringSB ;Find length for PutStringSB
  322 000000A4 F000 F906       BL               PutStringSB ;
  323 000000A8 200D            MOVS             R0,#0x0D    ;Carriage Return 
  324 000000AA F000 F8D9       BL               PutChar     ;
  325 000000AE 200A            MOVS             R0,#0x0A    ;Line Feed
  326 000000B0 F000 F8D6       BL               PutChar     ;
  327 000000B4 4810            LDR              R0,=Mission_Completed ;Mission completed!
  328 000000B6 F000 F909       BL               LengthStringSB ;Find length for PutStringSB
  329 000000BA F000 F8FB       BL               PutStringSB ;
  330 000000BE E7FE            B                .           ;End
  331 000000C0         
  332 000000C0         AccessDenied
  333 000000C0 480F            LDR              R0,=Denied  ;Dee-nied!
  334 000000C2 F000 F903       BL               LengthStringSB ;Find length for PutStringSB
  335 000000C6 F000 F8F5       BL               PutStringSB ;
  336 000000CA 200D            MOVS             R0,#0x0D    ;Carriage Return
  337 000000CC F000 F8C8       BL               PutChar     ;
  338 000000D0 200A            MOVS             R0,#0x0A    ;Line Feed
  339 000000D2 F000 F8C5       BL               PutChar     ;
  340 000000D6 E79A            B                Main        ;Let them try again
  341 000000D8         ;>>>>>   end main program code <<<<<



ARM Macro Assembler    Page 11 


  342 000000D8         ;Stay here
  343 000000D8 E7FE            B                .
  344 000000DA 00 00           ALIGN
  345 000000DC 00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              000001F4 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000         LTORG
  346 00000114         ;>>>>> begin subroutine code <<<<<
  347 00000114         
  348 00000114         ;This subroutine prints the least significant unsigned 
  349 00000114         ;byte value from R0 to the screen. 
  350 00000114         ;Inputs:
  351 00000114         ;R0 = value to print to the terminal screen in UB form
  352 00000114         ;Outputs
  353 00000114         ;None
  354 00000114         PutNumUB
  355 00000114 B502            PUSH             {R1,LR}
  356 00000116 21FF            MOVS             R1,#0xFF    ;Mask
  357 00000118 4008            ANDS             R0,R0,R1    ;Mask off everything but the last byte
  358 0000011A F000 F905       BL               PutNumU     ;Call PutNumU
  359 0000011E BD02            POP              {R1,PC}
  360 00000120         
  361 00000120         ;Timer Interrupt Service Routine
  362 00000120         ;THis subroutine increments a counter when RunStopWatch is equal to 0
  363 00000120         ;Otherwise it does not 
  364 00000120         PIT_ISR
  365 00000120 B672            CPSID            I
  366 00000122 48C1            LDR              R0,=RunStopWatch ;Initialize
  367 00000124 7800            LDRB             R0,[R0,#0]
  368 00000126 2800            CMP              R0,#0       ;If 1
  369 00000128 D100            BNE              INCR_COUNT
  370 0000012A E003            B                END_PIT_ISR ;If 0



ARM Macro Assembler    Page 12 


  371 0000012C         
  372 0000012C         INCR_COUNT
  373 0000012C 48BF            LDR              R0,=Count   ;Add #1 to count if stopwatch is running
  374 0000012E 6801            LDR              R1,[R0,#0]
  375 00000130 1C49            ADDS             R1,R1,#1
  376 00000132 6001            STR              R1,[R0,#0]  ;Store value
  377 00000134         
  378 00000134         END_PIT_ISR
  379 00000134 48BE            LDR              R0,=PIT_TFLG0 ;;Clear interrupt condition
  380 00000136 49BF            LDR              R1,=PIT_TFLG_TIF_MASK
  381 00000138 6001            STR              R1,[R0, #0]
  382 0000013A B662            CPSIE            I
  383 0000013C 4770            BX               LR
  384 0000013E         
  385 0000013E         ;Interrupt service routine for UART0 
  386 0000013E         ;Check status of interrupt that triggered the ISR
  387 0000013E         ;And react appropriately. If transmit interrupt enabled,
  388 0000013E         ;write to UART0 transmit data register. If rx enabled
  389 0000013E         ;enqueue to transmit queue from UART0 recieve data register
  390 0000013E         UART0_ISR
  391 0000013E B672            CPSID            I           ;Mask other interrupts
  392 00000140 B500            PUSH             {LR}
  393 00000142 48BD            LDR              R0, =UART0_BASE ;Base
  394 00000144         ;If txinterrupt enabled (UART0_C2 Bit 7 is set)
  395 00000144 78C1            LDRB             R1,[R0,#UART0_C2_OFFSET]
  396 00000146 2280            MOVS             R2,#UART0_C2_TIE_MASK
  397 00000148 4011            ANDS             R1, R1, R2
  398 0000014A D100            BNE              TX_ENABLED
  399 0000014C         ;If no TxInterrupt, check for Rx
  400 0000014C E00D            B                CHECK_RX_INT
  401 0000014E         TX_ENABLED
  402 0000014E 7901            LDRB             R1,[R0,#UART0_S1_OFFSET]
  403 00000150 2280            MOVS             R2, #UART0_S1_TDRE_MASK
  404 00000152 4011            ANDS             R1, R1, R2
  405 00000154 D009            BEQ              CHECK_RX_INT
  406 00000156         ;Dequeue character
  407 00000156         ;Load input params to initalize queue structure
  408 00000156 49B9            LDR              R1, =TxQueueRecord
  409 00000158 2250            MOVS             R2, #MAX_QUEUE
  410 0000015A F000 F831       BL               Dequeue
  411 0000015E         ;Dequeue was unsuccessful
  412 0000015E D202            BCS              DISABLE_TX



ARM Macro Assembler    Page 13 


  413 00000160         ;Dequeue was successful
  414 00000160 49B5            LDR              R1, =UART0_BASE
  415 00000162         ;Transmit Character Stored in R0
  416 00000162 71C8            STRB             R0, [R1, #UART0_D_OFFSET]
  417 00000164 E001            B                CHECK_RX_INT
  418 00000166         DISABLE_TX
  419 00000166         ;UART0 <- C2_T_RI
  420 00000166 212C            MOVS             R1,#UART0_C2_T_RI
  421 00000168 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  422 0000016A         CHECK_RX_INT
  423 0000016A 48B3            LDR              R0, =UART0_BASE
  424 0000016C         ;Check if an RxInterrupt exists
  425 0000016C 7901            LDRB             R1,[R0,#UART0_S1_OFFSET]
  426 0000016E 2220            MOVS             R2, #UART0_S1_RDRF_MASK
  427 00000170 4011            ANDS             R1, R1, R2
  428 00000172 D004            BEQ              END_ISR
  429 00000174         ;Receive character and store in R0
  430 00000174 48B0            LDR              R0, =UART0_BASE
  431 00000176 79C0            LDRB             R0,[R0, #UART0_D_OFFSET]
  432 00000178         ;Enqueue character with character stored in R0
  433 00000178         ;Load input params to initalize queue structure
  434 00000178 49B1            LDR              R1, =RxQueueRecord
  435 0000017A F000 F845       BL               Enqueue
  436 0000017E         ;No need to check return of EnQueue
  437 0000017E         ;character will be lost if the queue is full!
  438 0000017E         END_ISR
  439 0000017E         ;pop relevant registers off the stack
  440 0000017E         ;Unmask other interrupts
  441 0000017E B662            CPSIE            I
  442 00000180         ;Return back to our business
  443 00000180 BD00            POP              {PC}
  444 00000182         
  445 00000182         ;This subroutine prints  the hex representation of a value
  446 00000182         ;in r0 to the console
  447 00000182         ;Inputs:
  448 00000182         ; R0 - Value to print to the screen
  449 00000182         ;Outputs
  450 00000182         ; None
  451 00000182         PutNumHex
  452 00000182 B51C            PUSH             {R2,R3,R4,LR}
  453 00000184 2220            MOVS             R2,#32      ;Initialize counter
  454 00000186         PutNumHexLoop



ARM Macro Assembler    Page 14 


  455 00000186 2A00            CMP              R2,#0       ;Compare counter to 0
  456 00000188 DB10            BLT              EndPutNumHex
  457 0000018A 0003            MOVS             R3,R0       ;Move value tp r3
  458 0000018C 240F            MOVS             R4,#0x0F    ;Value to shift
  459 0000018E 40D3            LSRS             R3,R2       ;Shift to right most 
  460 00000190 401C            ANDS             R4,R4,R3    ;Mask 
  461 00000192 2C0A            CMP              R4,#10      ;Compare to ascii
  462 00000194 DA01            BGE              PrintLetter ;Its a letter        
  463 00000196 3430            ADDS             R4,#'0'     ;Its a number so print number
  464 00000198 E000            B                PrintNumber
  465 0000019A         PrintLetter
  466 0000019A 3437            ADDS             R4,R4,#55   ;Convert to ascii     
  467 0000019C         PrintNumber
  468 0000019C B401            PUSH             {R0}        ;Save R0 value
  469 0000019E 0020            MOVS             R0,R4       ;Initialize for put char
  470 000001A0 F000 F85E       BL               PutChar
  471 000001A4 BC01            POP              {R0}        ;Restore original value
  472 000001A6         ;Reset value in R3 and increment loop counter
  473 000001A6 2400            MOVS             R4,#0       ;Reset R4
  474 000001A8 1F12            SUBS             R2,R2,#4    ;Decrement counter
  475 000001AA E7EC            B                PutNumHexLoop
  476 000001AC         EndPutNumHex
  477 000001AC BD1C            POP              {R2,R3,R4,PC}
  478 000001AE         ;This subroutine initializes an empty queue
  479 000001AE         ;Input parameters:
  480 000001AE         ;   R0, queue buffer address 
  481 000001AE         ;   R1, queue record structure
  482 000001AE         ; R2, queue size
  483 000001AE         ;Output parameters:
  484 000001AE         ;   None 
  485 000001AE         ;Modified Registers
  486 000001AE         ; None 
  487 000001AE         InitQueue
  488 000001AE 6008            STR              R0,[R1,#IN_PTR] ;Initialize In pointer to start of queue
  489 000001B0 6048            STR              R0,[R1,#OUT_PTR] ;Initialize Out pointer to start of queue
  490 000001B2 6088            STR              R0,[R1,#BUF_START] ;Initialize buffer start to start of queue
  491 000001B4 1880            ADDS             R0,R0,R2    ;Add buff start to queue size
  492 000001B6 60C8            STR              R0,[R1,#BUF_PAST] ;store as buff past
  493 000001B8 610A            STR              R2,[R1,#BUF_SIZE] ;Store queue size as buff size
  494 000001BA 2000            MOVS             R0,#0       ;Initialize num enqd as zero
  495 000001BC 7448            STRB             R0,[R1,#NUM_ENQD] ;store num enqd 
  496 000001BE 4770            BX               LR



ARM Macro Assembler    Page 15 


  497 000001C0         ;This subroutine dequeues a character
  498 000001C0         ;Input paramters:
  499 000001C0         ; R1: Address of queue record structure
  500 000001C0         ;Output:
  501 000001C0         ; PSR C flag: success(0) or failure (1)
  502 000001C0         ; r0: Character to dequeued 
  503 000001C0         ;Modify: PSR
  504 000001C0         Dequeue
  505 000001C0 B41F            PUSH             {R0-R4}
  506 000001C2 7C4B            LDRB             R3,[R1,#NUM_ENQD] ;get number enqueued
  507 000001C4 2B00            CMP              R3,#0       ;Compare num enqued and 0
  508 000001C6 D915            BLS              QueueEmpty  ;Branch if num enqd =< 0
  509 000001C8 6848            LDR              R0,[R1,#OUT_PTR] ;get adress of outpointer
  510 000001CA 7800            LDRB             R0,[R0,#0]  ;Load actual value from queue
  511 000001CC 7C4B            LDRB             R3,[R1,#NUM_ENQD] ;Load number enqued
  512 000001CE 1E5B            SUBS             R3,R3,#1    ;Decrement num enqd
  513 000001D0 744B            STRB             R3,[R1,#NUM_ENQD] ;Store new num enqd value
  514 000001D2 684B            LDR              R3,[R1,#OUT_PTR] ;Load outpointer
  515 000001D4 1C5B            ADDS             R3,R3,#1    ;Increment outpointer
  516 000001D6 604B            STR              R3,[R1,#OUT_PTR] ;store new outpointer
  517 000001D8 68CC            LDR              R4,[R1,#BUF_PAST] ;Load buffer past
  518 000001DA 42A3            CMP              R3,R4       ;Compare to outpointer
  519 000001DC DA00            BGE              NeedToWrapAgain ;If outpointer >= BuffPast
  520 000001DE E001            B                ClearPSRDequeue
  521 000001E0         
  522 000001E0         NeedToWrapAgain
  523 000001E0 688B            LDR              R3,[R1,#BUF_START] ;Load buffewr start
  524 000001E2 604B            STR              R3,[R1,#OUT_PTR] ;Store buffer start as outpointer
  525 000001E4         ClearPSRDequeue
  526 000001E4 F3EF 8100       MRS              R1,APSR     ;Clear the PSR C flag
  527 000001E8 2320            MOVS             R3,#0x20
  528 000001EA 0609            LSLS             R1,R1,#24
  529 000001EC 4399            BICS             R1,R1,R3
  530 000001EE F381 8800       MSR              APSR,R1
  531 000001F2 E007            B                EndDequeue
  532 000001F4         QueueEmpty
  533 000001F4 F3EF 8000       MRS              R0,APSR     ;Set the PSR C flag
  534 000001F8 2120            MOVS             R1,#0x20
  535 000001FA 0609            LSLS             R1,R1,#24
  536 000001FC 4308            ORRS             R0,R0,R1
  537 000001FE F380 8800       MSR              APSR, R0
  538 00000202 E7FF            B                EndDequeue



ARM Macro Assembler    Page 16 


  539 00000204         EndDequeue
  540 00000204 BC1E            POP              {R1-R4}
  541 00000206 4770            BX               LR
  542 00000208         
  543 00000208         ;This subroutine enqueues a character
  544 00000208         ;Input paramters:
  545 00000208         ; r0: Character to enque 
  546 00000208         ; R1: Address of queue record structure
  547 00000208         ;Output:
  548 00000208         ; PSR C flag: success(0) or failure (1)
  549 00000208         ;Modify: PSR
  550 00000208         Enqueue
  551 00000208 B41C            PUSH             {R2-R4}
  552 0000020A 7C4B            LDRB             R3,[R1, #NUM_ENQD] ;Load number enqued
  553 0000020C 7C0C            LDRB             R4,[R1, #BUF_SIZE] ;Load buffer size
  554 0000020E 42A3            CMP              R3,R4       ;Compare
  555 00000210 DA00            BGE              QueueFull   ;If number enqd >= buffsize then Queue full
  556 00000212 E007            B                BeginEnqueue
  557 00000214         QueueFull
  558 00000214 F3EF 8100       MRS              R1,APSR     ;Set PSR C flag to 1  
  559 00000218 2320            MOVS             R3,#0x20
  560 0000021A 061B            LSLS             R3,R3,#24
  561 0000021C 4319            ORRS             R1,R1,R3
  562 0000021E F381 8800       MSR              APSR,R1
  563 00000222 E01B            B                EndEnqueue
  564 00000224         
  565 00000224         BeginEnqueue
  566 00000224 680B            LDR              R3,[R1, #IN_PTR] ;Load inpointer
  567 00000226 7018            STRB             R0,[R3, #0] ;Store character at inpointer
  568 00000228 1C5B            ADDS             R3,R3,#1    ;Increment inpointer
  569 0000022A 600B            STR              R3,[R1,#IN_PTR] ;Store inpointer
  570 0000022C 7C4B            LDRB             R3,[R1,#NUM_ENQD] ;Load num enqd
  571 0000022E 1C5B            ADDS             R3,R3,#1    ;Increment num enqd
  572 00000230 744B            STRB             R3,[R1,#NUM_ENQD] ;Store num enqd
  573 00000232 680B            LDR              R3,[R1,#IN_PTR] ;Load inpointer
  574 00000234 68CC            LDR              R4,[R1,#BUF_PAST] ;Load buffer past
  575 00000236 42A3            CMP              R3,R4       ;If inpointer >= buff past     
  576 00000238 DA07            BGE              NeedToWrap
  577 0000023A F3EF 8200       MRS              R2,APSR     ;Clear C flag of PSR
  578 0000023E 2320            MOVS             R3,#0x20
  579 00000240 0612            LSLS             R2,R2,#24
  580 00000242 439A            BICS             R2,R2,R3



ARM Macro Assembler    Page 17 


  581 00000244 F382 8800       MSR              APSR,R2
  582 00000248 E008            B                EndEnqueue
  583 0000024A         
  584 0000024A         NeedToWrap
  585 0000024A 688A            LDR              R2,[R1,#BUF_START] ;Load buff start
  586 0000024C 600A            STR              R2,[R1,#IN_PTR] ;Store buff start as inpointer
  587 0000024E F3EF 8200       MRS              R2,APSR     ;Clear the PSR C flag 
  588 00000252 2320            MOVS             R3,#0x20
  589 00000254 0612            LSLS             R2,R2,#24
  590 00000256 439A            BICS             R2,R2,R3
  591 00000258 F382 8800       MSR              APSR,R2
  592 0000025C         EndEnqueue
  593 0000025C BC1C            POP              {R2,R3,R4}
  594 0000025E 4770            BX               LR
  595 00000260         
  596 00000260         
  597 00000260         ;This subroutine sends a character out of UART0 using interrupts
  598 00000260         ;Inputs
  599 00000260         ; R0 - Character to enqueue to TxQueue
  600 00000260         ;Return 
  601 00000260         ; None
  602 00000260         
  603 00000260         PutChar
  604 00000260 B503            PUSH             {R0,R1,LR}
  605 00000262 4976            LDR              R1, =TxQueueRecord
  606 00000264         REPEAT_ENQ
  607 00000264         ;Mask all other interrupts
  608 00000264 B672            CPSID            I
  609 00000266         ;Critical section -> enqueue character
  610 00000266         ;Enqueue character that's already in R0
  611 00000266 F7FF FFCF       BL               Enqueue
  612 0000026A         ;Enable interrupts
  613 0000026A B662            CPSIE            I
  614 0000026C D2FA            BCS              REPEAT_ENQ
  615 0000026E         ;Enable UART0 Transmitter, reciever, and rx interrupt
  616 0000026E 4872            LDR              R0,=UART0_BASE
  617 00000270 21AC            MOVS             R1,#UART0_C2_TI_RI
  618 00000272 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  619 00000274         ;Pop original register values off the stack
  620 00000274 BD03            POP              {R0,R1,PC}
  621 00000276         
  622 00000276         ;This subroutine receives a character from UART0 using interrupts



ARM Macro Assembler    Page 18 


  623 00000276         ;Inputs 
  624 00000276         ; None
  625 00000276         ;Return
  626 00000276         ; R0 - Character dequeued from RxQueue
  627 00000276         GetChar
  628 00000276 B502            PUSH             {R1,LR}     ; Push varibles on the stack to avoid loss
  629 00000278 4971            LDR              R1, =RxQueueRecord
  630 0000027A         REPEAT_DEQ
  631 0000027A         ;Mask all interrupts
  632 0000027A B672            CPSID            I
  633 0000027C         ;Critical code section - dequeue
  634 0000027C F7FF FFA0       BL               Dequeue
  635 00000280         ;Re enable interrupts
  636 00000280 B662            CPSIE            I
  637 00000282 D2FA            BCS              REPEAT_DEQ
  638 00000284 BD02            POP              {R1,PC}
  639 00000286         
  640 00000286         
  641 00000286         ;The follwing subroutine reads a string of chars from the keyboard
  642 00000286         ;and stores them in a string dtarting from R0. For each character 
  643 00000286         ;up to R1-1 it echoes the character and when the carage character (13-10 0D-16)
  644 00000286         ;is not recieved it null terminates the string. it then moves
  645 00000286         ;the cursor to the begining of the next line
  646 00000286         ;Input parameters:
  647 00000286         ;   R1 one more than the oveflow buffer
  648 00000286         ; R0 pointer to address of string 
  649 00000286         ;Output parameters:
  650 00000286         ;   None
  651 00000286         ;Modified Registers
  652 00000286         ;   None. The original contents of the registers are restored 
  653 00000286         ;                 
  654 00000286         GetStringSB
  655 00000286 B50E            PUSH             {R1,R2,R3,LR}
  656 00000288 2200            MOVS             R2,#0       ;Initalize string offset to zero
  657 0000028A         GetStringSBLoop
  658 0000028A B401            PUSH             {R0}        ;Push Pointer value on stack
  659 0000028C F7FF FFF3       BL               GetChar     ;Get next char
  660 00000290 0003            MOVS             R3,R0       ;Move char to r3
  661 00000292 BC01            POP              {R0}        ;Return pointer value to R0
  662 00000294 2B0D            CMP              R3,#13      ;Compare char to carrage return
  663 00000296 D00A            BEQ              EndGetStringSB
  664 00000298 2900            CMP              R1,#0       ;If there is no more character



ARM Macro Assembler    Page 19 


  665 0000029A D0F6            BEQ              GetStringSBLoop
  666 0000029C B401            PUSH             {R0}        ;Save Pointer value on stack
  667 0000029E 0018            MOVS             R0,R3       ;move char to r3 for putchar
  668 000002A0 F7FF FFDE       BL               PutChar
  669 000002A4 BC01            POP              {R0}        ;Restore pointer value to R0
  670 000002A6 5483            STRB             R3,[R0,R2]  ;Store char at pointer with offset
  671 000002A8 1E49            SUBS             R1,R1,#1    ;Decrement number of chars
  672 000002AA 1C52            ADDS             R2,R2,#1    ;Increment offset
  673 000002AC E7ED            B                GetStringSBLoop
  674 000002AE         EndGetStringSB
  675 000002AE         
  676 000002AE 2300            MOVS             R3,#0       ;null
  677 000002B0 5483            STRB             R3,[R0,R2]  ;null terminate
  678 000002B2 BD0E            POP              {R1,R2,R3,PC}
  679 000002B4         
  680 000002B4         
  681 000002B4         ;Displays a null terminated string to the terminal screen from memory starting at R0 
  682 000002B4         ;Preventing overun of the buffer capacity specified by R1
  683 000002B4         ;Leaves cursor specified in R1
  684 000002B4         
  685 000002B4         PutStringSB
  686 000002B4 B50F            PUSH             {R0-R3,LR}
  687 000002B6 0002            MOVS             R2,R0       ;Move adress to R2
  688 000002B8 2300            MOVS             R3,#0
  689 000002BA         ReadChar
  690 000002BA 2900            CMP              R1, #0      ;If string is empty
  691 000002BC D005            BEQ              EndPutStringSB
  692 000002BE 5CD0            LDRB             R0,[R2,R3]  ;Put char in R3
  693 000002C0 F7FF FFCE       BL               PutChar
  694 000002C4 1E49            SUBS             R1,R1,#1    ;Decrement number of chars
  695 000002C6 1C5B            ADDS             R3,R3,#1    ;Increment offset
  696 000002C8 E7F7            B                ReadChar
  697 000002CA         EndPutStringSB
  698 000002CA BD0F            POP              {R0-R3,PC}
  699 000002CC         
  700 000002CC         ;Determines how many characters are in a a null terminated string
  701 000002CC         ;Memory of string starts in R0 and returns number of characters in R2
  702 000002CC         ;Prevents overrun of of buffer capacity specified in R1
  703 000002CC         ;
  704 000002CC         ;Input parameters:
  705 000002CC         ; R0 pointer to address of string 
  706 000002CC         ;Output parameters:



ARM Macro Assembler    Page 20 


  707 000002CC         ;   R1: number of characters in String
  708 000002CC         ;Modified Registers
  709 000002CC         ;   None. The original contents of the registers are restored 
  710 000002CC         ;
  711 000002CC         
  712 000002CC         LengthStringSB
  713 000002CC B51D            PUSH             {R0,R2,R3,R4,LR}
  714 000002CE 214F            MOVS             R1,#MAX_STRING
  715 000002D0 2200            MOVS             R2,#0       ;Initalize length to 0
  716 000002D2 2400            MOVS             R4,#0       ;Initalize offset to 0
  717 000002D4         LengthStringSBLoop
  718 000002D4 428A            CMP              R2,R1       ;Compare Max_String to 0
  719 000002D6 DA05            BGE              EndLengthStringSB ;If Max_string < 0
  720 000002D8 5D03            LDRB             R3,[R0,R4]  ;Load first character in string
  721 000002DA 2B00            CMP              R3,#0       ;Compare char to 0
  722 000002DC D002            BEQ              EndLengthStringSB ;If null terminated then end
  723 000002DE 1C64            ADDS             R4,R4,#1    ;Increment offset
  724 000002E0 1C52            ADDS             R2,R2,#1    ;Increment lenghth 
  725 000002E2 E7F7            B                LengthStringSBLoop
  726 000002E4         EndLengthStringSB
  727 000002E4 0011            MOVS             R1,R2       ;Move length to R1
  728 000002E6 BD1D            POP              {R0,R2,R3,R4,PC}
  729 000002E8         
  730 000002E8         ;Stuff  
  731 000002E8         DIVU
  732 000002E8 B404            PUSH             {R2}        ;store R2 Value
  733 000002EA 2200            MOVS             R2,#0       ;move 0 to R2 for quotient
  734 000002EC 2800            CMP              R0,#0       ;Compare divisor to 0
  735 000002EE D010            BEQ              SETCARRY    ;if divisor = 0 go to SETCARRY
  736 000002F0         WHILE
  737 000002F0 4281            CMP              R1,R0       ;Compare R1 to R0
  738 000002F2 D302            BLO              ENDWHILE    ;if dividend<Divisor End loop
  739 000002F4 1C52            ADDS             R2,R2,#1    ;Add 1 to quotient
  740 000002F6 1A09            SUBS             R1,R1,R0    ;Dividend - divisor
  741 000002F8 E7FA            B                WHILE       ;branch to start of while  
  742 000002FA         ENDWHILE
  743 000002FA 0010            MOVS             R0,R2       ;move quotient to R0, so R0 remainder R1
  744 000002FC BC04            POP              {R2}        ;revert R2 to value before subroutine
  745 000002FE B403            PUSH             {R0,R1}     ;push R0 and R1
  746 00000300 F3EF 8000       MRS              R0,APSR     ;Set C flag to 0
  747 00000304 2120            MOVS             R1,#0x20    ;
  748 00000306 0609            LSLS             R1,#24      ;Shift 24 places (to most significant byte)



ARM Macro Assembler    Page 21 


  749 00000308 4388            BICS             R0,R0,R1    ; 
  750 0000030A F380 8800       MSR              APSR,R0     ; 
  751 0000030E BC03            POP              {R0,R1}     ;revert R0 and R1 to answer 
  752 00000310 4770            BX               LR          ;Go back to program
  753 00000312         SETCARRY
  754 00000312 BC04            POP              {R2}        ;Pop R2
  755 00000314 B403            PUSH             {R0,R1}     ;Store R0 and R1
  756 00000316 F3EF 8000       MRS              R0,APSR     ;Set C flag to 1
  757 0000031A 2120            MOVS             R1,#0x20    ;
  758 0000031C 0609            LSLS             R1,#24      ;Shift 24 places (to most significant byte)
  759 0000031E 4308            ORRS             R0,R0,R1    ;
  760 00000320 F380 8800       MSR              APSR,R0     ;
  761 00000324 BC03            POP              {R0,R1}     ;Revert R0 and R1 to answer
  762 00000326 4770            BX               LR
  763 00000328         
  764 00000328         ;Prints the text in decimal of unsigned word value R0 in terminal screen
  765 00000328         ;Using DivU
  766 00000328         ;Input parameters:
  767 00000328         ;   R0 is an Unsigned Word Value to print
  768 00000328         ;Output parameters:
  769 00000328         ;   None
  770 00000328         ;Modified Registers
  771 00000328         ;   PSR: (after return, nothing else)
  772 00000328         PutNumU
  773 00000328 B503            PUSH             {R0,R1,LR}  ;Push registers as to not overwrite original values
  774 0000032A 0001            MOVS             R1,R0
  775 0000032C 200A            MOVS             R0,#10      ;Initialize divisor
  776 0000032E F7FF FFDB       BL               DIVU        ;Divide binary value by 10, remainder (which is R1) is ASCii
                                                            
  777 00000332 3030            ADDS             R0,R0,#48   ;Convert MSD to Ascii
  778 00000334 2830            CMP              R0,#48
  779 00000336 D001            BEQ              NEXTDIGIT
  780 00000338 F7FF FF92       BL               PutChar     ;Display on terminal, R1 is input for R1
  781 0000033C         NEXTDIGIT
  782 0000033C 3130            ADDS             R1,R1,#48   ;Convert LSD to ASCII
  783 0000033E 0008            MOVS             R0,R1       ;Initialize PUTCHAR
  784 00000340 200D            MOVS             R0, #0x0D
  785 00000342 F7FF FF8D       BL               PutChar
  786 00000346 200A            MOVS             R0, #0x0A
  787 00000348 F7FF FF8A       BL               PutChar
  788 0000034C F7FF FF88       BL               PutChar     ;Print last digit
  789 00000350 BD03            POP              {R0,R1,PC}



ARM Macro Assembler    Page 22 


  790 00000352         
  791 00000352         
  792 00000352         Init_UART0_IRQ
  793 00000352         ;Initalize UART0 for Serial Driver
  794 00000352         ;Allocate R0-2 for Ri=k 
  795 00000352         ;Store prevoius values for restoration
  796 00000352 B507            PUSH             {R0, R1, R2, LR}
  797 00000354         ;Initalize rxQueue
  798 00000354 493A            LDR              R1, =RxQueueRecord
  799 00000356 483B            LDR              R0, =RxQueue
  800 00000358 2204            MOVS             R2, #Q_BUF_SZ
  801 0000035A F7FF FF28       BL               InitQueue
  802 0000035E 4937            LDR              R1, =TxQueueRecord
  803 00000360 4839            LDR              R0, =TxQueue
  804 00000362 2204            MOVS             R2, #Q_BUF_SZ
  805 00000364 F7FF FF23       BL               InitQueue
  806 00000368         ;Select MCGPLLCLK / 2 as UART0 clock source
  807 00000368 483C            LDR              R0,=SIM_SOPT2
  808 0000036A 493D            LDR              R1,=SIM_SOPT2_UART0SRC_MASK
  809 0000036C 6802            LDR              R2,[R0,#0]
  810 0000036E 438A            BICS             R2,R2,R1
  811 00000370 493C            LDR              R1,=SIM_SOPT2_UART0_MCGPLLCLK_DIV2
  812 00000372 430A            ORRS             R2,R2,R1
  813 00000374 6002            STR              R2,[R0,#0]
  814 00000376         ;Enable external connection for UART0
  815 00000376 483C            LDR              R0,=SIM_SOPT5
  816 00000378 493C            LDR              R1,= SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
  817 0000037A 6802            LDR              R2,[R0,#0]
  818 0000037C 438A            BICS             R2,R2,R1
  819 0000037E 6002            STR              R2,[R0,#0]
  820 00000380         ;Enable clock for UART0 module
  821 00000380 483B            LDR              R0,=SIM_SCGC4
  822 00000382 493C            LDR              R1,= SIM_SCGC4_UART0_MASK
  823 00000384 6802            LDR              R2,[R0,#0]
  824 00000386 430A            ORRS             R2,R2,R1
  825 00000388 6002            STR              R2,[R0,#0]
  826 0000038A         ;Enable clock for Port A module
  827 0000038A 483B            LDR              R0,=SIM_SCGC5
  828 0000038C 493B            LDR              R1,= SIM_SCGC5_PORTA_MASK
  829 0000038E 6802            LDR              R2,[R0,#0]
  830 00000390 430A            ORRS             R2,R2,R1
  831 00000392 6002            STR              R2,[R0,#0]



ARM Macro Assembler    Page 23 


  832 00000394         ;Connect PORT A Pin 1 (PTA1) to UART0 Rx (J1 Pin 02)
  833 00000394 483A            LDR              R0,=PORTA_PCR1
  834 00000396 493B            LDR              R1,=PORT_PCR_SET_PTA1_UART0_RX
  835 00000398 6001            STR              R1,[R0,#0]
  836 0000039A         ;Connect PORT A Pin 2 (PTA2) to UART0 Tx (J1 Pin 04)
  837 0000039A 483B            LDR              R0,=PORTA_PCR2
  838 0000039C 4939            LDR              R1,=PORT_PCR_SET_PTA2_UART0_TX
  839 0000039E 6001            STR              R1,[R0,#0]
  840 000003A0         ;Disable UART0 receiver and transmitter
  841 000003A0 4825            LDR              R0,=UART0_BASE
  842 000003A2 210C            MOVS             R1,#UART0_C2_T_R
  843 000003A4 78C2            LDRB             R2,[R0,#UART0_C2_OFFSET]
  844 000003A6 438A            BICS             R2,R2,R1
  845 000003A8 70C2            STRB             R2,[R0,#UART0_C2_OFFSET]
  846 000003AA         ;Init NVIC for UART0 Interrupts
  847 000003AA         ;Set UART0 IRQ Priority
  848 000003AA 4838            LDR              R0, =UART0_IPR
  849 000003AC 4938            LDR              R1, =NVIC_IPR_UART0_MASK
  850 000003AE 4A38            LDR              R2, =NVIC_IPR_UART0_PRI_3
  851 000003B0 6803            LDR              R3, [R0, #0]
  852 000003B2 438B            BICS             R3, R3, R1
  853 000003B4 4313            ORRS             R3, R3, R2
  854 000003B6 6003            STR              R3, [R0, #0]
  855 000003B8         ;Clear any pending UART0 Interrupts
  856 000003B8 4836            LDR              R0, =NVIC_ICPR
  857 000003BA 4937            LDR              R1, =NVIC_ICPR_UART0_MASK
  858 000003BC 6001            STR              R1, [R0, #0]
  859 000003BE         ;Unmask UART0 interrupts
  860 000003BE 4837            LDR              R0, =NVIC_ISER
  861 000003C0 4935            LDR              R1, =NVIC_ISER_UART0_MASK
  862 000003C2 6001            STR              R1, [R0, #0]
  863 000003C4         ;Init UART0 for 8N1 format at 9600 Baud,
  864 000003C4         ;and enable the rx interrupt
  865 000003C4 481C            LDR              R0, =UART0_BASE
  866 000003C6 2101            MOVS             R1,#UART0_BDH_9600
  867 000003C8 7001            STRB             R1,[R0,#UART0_BDH_OFFSET]
  868 000003CA 2138            MOVS             R1,#UART0_BDL_9600
  869 000003CC 7041            STRB             R1,[R0,#UART0_BDL_OFFSET]
  870 000003CE 2100            MOVS             R1,#UART0_C1_8N1
  871 000003D0 7081            STRB             R1,[R0,#UART0_C1_OFFSET]
  872 000003D2 2100            MOVS             R1,#UART0_C3_NO_TXINV
  873 000003D4 7181            STRB             R1,[R0,#UART0_C3_OFFSET]



ARM Macro Assembler    Page 24 


  874 000003D6 210F            MOVS             R1,#UART0_C4_NO_MATCH_OSR_16
  875 000003D8 7281            STRB             R1,[R0,#UART0_C4_OFFSET]
  876 000003DA 2100            MOVS             R1,#UART0_C5_NO_DMA_SSR_SYNC
  877 000003DC 72C1            STRB             R1,[R0,#UART0_C5_OFFSET]
  878 000003DE 211F            MOVS             R1,#UART0_S1_CLEAR_FLAGS
  879 000003E0 7101            STRB             R1,[R0,#UART0_S1_OFFSET]
  881 000003E2 21C0            MOVS             R1,               #UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
  882 000003E4 7141            STRB             R1,[R0,#UART0_S2_OFFSET]
  883 000003E6         ;Enable UART0 Transmitter, reciever, and rx interrupt
  884 000003E6 212C            MOVS             R1,#UART0_C2_T_RI
  885 000003E8 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  886 000003EA         ;Pop prevous R0-2 values off the stack.
  887 000003EA BD07            POP              {R0, R1, R2, PC}
  888 000003EC         ;This subroutine initializes PIT to generate an interupt
  889 000003EC         ;every 0.01s from channel 0
  890 000003EC         ;Inputs: 
  891 000003EC         ; None
  892 000003EC         ;Outputs: 
  893 000003EC         ; None
  894 000003EC         Init_PIT_IRQ
  895 000003EC B672            CPSID            I
  896 000003EE B507            PUSH             {R0, R1, R2, LR}
  897 000003F0 482B            LDR              R0, =SIM_SCGC6 ;Initialize
  898 000003F2 492C            LDR              R1, =SIM_SCGC6_PIT_MASK
  899 000003F4 6802            LDR              R2, [R0, #0]
  900 000003F6 430A            ORRS             R2, R2, R1  ;Set only the PIT bit on SIM_SCGC6
  901 000003F8 6002            STR              R2, [R0, #0] ;Store set bit back on to the register
  902 000003FA 482B            LDR              R0, =PIT_CH0_BASE ;Disable timer 0 
  903 000003FC 490D            LDR              R1, =PIT_TCTRL_TEN_MASK
  904 000003FE 6882            LDR              R2, [R0, #PIT_TCTRL_OFFSET]
  905 00000400 438A            BICS             R2, R2, R1
  906 00000402 6082            STR              R2, [R0, #PIT_TCTRL_OFFSET]
  907 00000404 4829            LDR              R0, =PIT_IPR ;Set PIT Interrupt Priority
  908 00000406 4911            LDR              R1, =(PIT_IRQ_PRI << PIT_PRI_POS)
  909 00000408 6001            STR              R1, [R0, #0]
  910 0000040A 4824            LDR              R0, =NVIC_ISER ;Unmask PIT Interrupts
  911 0000040C 4929            LDR              R1, =PIT_IRQ_MASK
  912 0000040E 6001            STR              R1, [R0, #0]
  913 00000410 4829            LDR              R0, =PIT_BASE ;Enable the PIT timer module
  914 00000412 4908            LDR              R1, =PIT_MCR_EN_FRZ ;Enable the FRZ to stop timer in debug mode
  915 00000414 6001            STR              R1, [R0, #PIT_MCR_OFFSET]
  916 00000416 4824            LDR              R0, =PIT_CH0_BASE ;Request interrupts every 0.01 seconds



ARM Macro Assembler    Page 25 


  917 00000418 4928            LDR              R1, =PIT_LDVAL_10ms ;239,999
  918 0000041A 6001            STR              R1, [R0, #PIT_LDVAL_OFFSET]
  919 0000041C 4822            LDR              R0, =PIT_CH0_BASE ;Enable PIT timer channel 0 for interrupts
  920 0000041E 2103            MOVS             R1, #PIT_TCTRL_CH_IE ;Interrupt enabled mask to write to the register
  921 00000420 6081            STR              R1, [R0, #PIT_TCTRL_OFFSET]
  922 00000422         
  923 00000422         
  924 00000422 B662            CPSIE            I
  925 00000424 BD07            POP              {R0, R1, R2, PC}
  926 00000426         ;>>>>>   end subroutine code <<<<<
  927 00000426 00 00           ALIGN
  928 00000428         ;****************************************************************
  929 00000428         ;Vector Table Mapped to Address 0 at Reset
  930 00000428         ;Linker requires __Vectors to be exported
  931 00000428 00000000 
              00000000 
              4003710C 
              00000001 
              4006A000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              40048004 
              0C000000 
              04010000 
              40048010 
              00010007 
              40048034 
              00000400 
              40048038 
              00000200 
              40049004 
              01000200 
              40049008 
              E000E40C 
              000000C0 
              E000E280 



ARM Macro Assembler    Page 26 


              00001000 
              E000E100 
              4004803C 
              00800000 
              40037100 
              E000E414 
              00000000 
              00400000 
              40037000 
              0003A97F         AREA             RESET, DATA, READONLY
  932 00000000                 EXPORT           __Vectors
  933 00000000                 EXPORT           __Vectors_End
  934 00000000                 EXPORT           __Vectors_Size
  935 00000000                 IMPORT           __initial_sp
  936 00000000                 IMPORT           Dummy_Handler
  937 00000000         __Vectors
  938 00000000         ;ARM core vectors
  939 00000000 00000000        DCD              __initial_sp ;00:end of stack
  940 00000004 00000000        DCD              Reset_Handler ;01:reset vector
  941 00000008 00000000        DCD              Dummy_Handler ;02:NMI
  942 0000000C 00000000        DCD              Dummy_Handler ;03:hard fault
  943 00000010 00000000        DCD              Dummy_Handler ;04:(reserved)
  944 00000014 00000000        DCD              Dummy_Handler ;05:(reserved)
  945 00000018 00000000        DCD              Dummy_Handler ;06:(reserved)
  946 0000001C 00000000        DCD              Dummy_Handler ;07:(reserved)
  947 00000020 00000000        DCD              Dummy_Handler ;08:(reserved)
  948 00000024 00000000        DCD              Dummy_Handler ;09:(reserved)
  949 00000028 00000000        DCD              Dummy_Handler ;10:(reserved)
  950 0000002C 00000000        DCD              Dummy_Handler ;11:SVCall (supervisor call)
  951 00000030 00000000        DCD              Dummy_Handler ;12:(reserved)
  952 00000034 00000000        DCD              Dummy_Handler ;13:(reserved)
  953 00000038 00000000        DCD              Dummy_Handler ;14:PendableSrvReq (pendable request 
  954 0000003C         ;   for system service)
  955 0000003C 00000000        DCD              Dummy_Handler ;15:SysTick (system tick timer)
  956 00000040 00000000        DCD              Dummy_Handler ;16:DMA channel 0 xfer complete/error
  957 00000044 00000000        DCD              Dummy_Handler ;17:DMA channel 1 xfer complete/error
  958 00000048 00000000        DCD              Dummy_Handler ;18:DMA channel 2 xfer complete/error
  959 0000004C 00000000        DCD              Dummy_Handler ;19:DMA channel 3 xfer complete/error
  960 00000050 00000000        DCD              Dummy_Handler ;20:(reserved)
  961 00000054 00000000        DCD              Dummy_Handler ;21:command complete; read collision
  962 00000058 00000000        DCD              Dummy_Handler ;22:low-voltage detect;
  963 0000005C         ;   low-voltage warning



ARM Macro Assembler    Page 27 


  964 0000005C 00000000        DCD              Dummy_Handler ;23:low leakage wakeup
  965 00000060 00000000        DCD              Dummy_Handler ;24:I2C0
  966 00000064 00000000        DCD              Dummy_Handler ;25:I2C1
  967 00000068 00000000        DCD              Dummy_Handler ;26:SPI0 (all IRQ sources)
  968 0000006C 00000000        DCD              Dummy_Handler ;27:SPI1 (all IRQ sources)
  969 00000070 00000000        DCD              UART0_ISR   ;28:UART0 (status; error)
  970 00000074 00000000        DCD              Dummy_Handler ;29:UART1 (status; error)
  971 00000078 00000000        DCD              Dummy_Handler ;30:UART2 (status; error)
  972 0000007C 00000000        DCD              Dummy_Handler ;31:ADC0
  973 00000080 00000000        DCD              Dummy_Handler ;32:CMP0
  974 00000084 00000000        DCD              Dummy_Handler ;33:TPM0
  975 00000088 00000000        DCD              Dummy_Handler ;34:TPM1
  976 0000008C 00000000        DCD              Dummy_Handler ;35:TPM2
  977 00000090 00000000        DCD              Dummy_Handler ;36:RTC (alarm)
  978 00000094 00000000        DCD              Dummy_Handler ;37:RTC (seconds)
  979 00000098 00000000        DCD              PIT_ISR     ;38:PIT (all IRQ sources)
  980 0000009C 00000000        DCD              Dummy_Handler ;39:I2S0
  981 000000A0 00000000        DCD              Dummy_Handler ;40:USB0
  982 000000A4 00000000        DCD              Dummy_Handler ;41:DAC0
  983 000000A8 00000000        DCD              Dummy_Handler ;42:TSI0
  984 000000AC 00000000        DCD              Dummy_Handler ;43:MCG
  985 000000B0 00000000        DCD              Dummy_Handler ;44:LPTMR0
  986 000000B4 00000000        DCD              Dummy_Handler ;45:Segment LCD
  987 000000B8 00000000        DCD              Dummy_Handler ;46:PORTA pin detect
  988 000000BC 00000000        DCD              Dummy_Handler ;47:PORTC and PORTD pin detect
  989 000000C0         __Vectors_End
  990 000000C0 000000C0 
                       __Vectors_Size
                               EQU              __Vectors_End - __Vectors
  991 000000C0                 ALIGN
  992 000000C0         ;****************************************************************
  993 000000C0         ;Constants
  994 000000C0                 AREA             MyConst,DATA,READONLY
  995 00000000         ;>>>>> begin constants here <<<<<
  996 00000000 20 78 20 
              30 2E 30 
              31 20 73 
              00       TimeString
                               DCB              " x 0.01 s", 0
  997 0000000A 45 6E 74 
              65 72 20 
              74 68 65 



ARM Macro Assembler    Page 28 


              20 61 63 
              63 65 73 
              73 20 63 
              6F 64 65 
              2E 00    AccessCodePrompt
                               DCB              "Enter the access code.", 0
  998 00000021 2D 2D 41 
              63 63 65 
              73 73 20 
              67 72 61 
              6E 74 65 
              64 00    Granted DCB              "--Access granted", 0
  999 00000032 2D 2D 41 
              63 63 65 
              73 73 20 
              64 65 6E 
              69 65 64 
              00       Denied  DCB              "--Access denied", 0
 1000 00000042 4D 69 73 
              73 69 6F 
              6E 20 63 
              6F 6D 70 
              6C 65 74 
              65 64 21 
              00       Mission_Completed
                               DCB              "Mission completed!", 0
 1001 00000055 32 35 30 
              31 35 31 
              31 30 00 AccessCode
                               DCB              "25015110", 0
 1002 0000005E         ;>>>>>   end constants here <<<<<
 1003 0000005E 00 00           ALIGN
 1004 00000060         ;****************************************************************
 1005 00000060         ;Variables
 1006 00000060                 AREA             MyData,DATA,READWRITE
 1007 00000000         ;>>>>> begin variables here <<<<<
 1008 00000000         ;Rx Queue
 1009 00000000 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 



ARM Macro Assembler    Page 29 


              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00    RxQueue SPACE            MAX_QUEUE
 1010 00000050 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 RxQueueRecord
                               SPACE            Q_REC_SZ
 1011 00000062         
 1012 00000062 00 00           ALIGN
 1013 00000064         ;Tx Queue
 1014 00000064 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 



ARM Macro Assembler    Page 30 


              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00    TxQueue SPACE            MAX_QUEUE
 1015 000000B4 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 TxQueueRecord
                               SPACE            Q_REC_SZ
 1016 000000C6 00 00           ALIGN
 1017 000000C8         ;Queue 
 1018 000000C8 00 00 00 
              00       Queue   SPACE            Q_BUF_SZ
 1019 000000CC 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 QueueRecord
                               SPACE            Q_REC_SZ
 1020 000000DE 00 00           ALIGN
 1021 000000E0 00 00   StringReversal
                               SPACE            2
 1022 000000E2 00 00           ALIGN
 1023 000000E4 00      RunStopWatch
                               SPACE            1
 1024 000000E5 00 00 00        ALIGN



ARM Macro Assembler    Page 31 


 1025 000000E8 00 00   Count   SPACE            2
 1026 000000EA 00 00           ALIGN
 1027 000000EC 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00       InputString
                               SPACE            MAX_STRING
 1028 0000013B         ;>>>>>   end variables here <<<<<
 1029 0000013B 00              ALIGN
 1030 0000013C                 END
Command Line: --debug --length=49 --width=120 --diag_suppress=9931 --cpu=Cortex-M0+ --apcs=interwork --depend=.\exercise
10.d -o.\exercise10.o -ID:\Assembly\Exercise10\RTE -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.6.0\Device\Include -IC:
\Keil_v5\ARM\CMSIS\Include --predefine="__UVISION_VERSION SETA 515" --predefine="MKL46Z256xxx4 SETA 1" --list=.\exercise
10.lst Exercise10.s
