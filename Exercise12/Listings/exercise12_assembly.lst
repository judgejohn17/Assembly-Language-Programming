


ARM Macro Assembler    Page 1 


    1 00000000         ;TTL Exercise 12: D/A Conversion, A/D Conversion, PWM, and Servos with Mixed Assembly Language an
                       d C
    2 00000000         ;****************************************************************
    3 00000000         ;This program tansforms data between Digital to Analog, Analog to 
    4 00000000         ;Digital, PWM, and Servo positions
    5 00000000         ;Name:  John Judge
    6 00000000         ;Date:  5/2/16
    7 00000000         ;Class:  CMPE-250
    8 00000000         ;Section:  Thursdays 2:00PM - 3:50 PM
    9 00000000         ;---------------------------------------------------------------
   10 00000000         ;Keil Template for KL46 Assembly with Keil C startup
   11 00000000         ;R. W. Melton
   12 00000000         ;April 20, 2015
   13 00000000         ;****************************************************************
   14 00000000         ;Assembler directives
   15 00000000                 THUMB
   16 00000000                 GBLL             MIXED_ASM_C
   17 00000000 TRUE     
                       MIXED_ASM_C
                               SETL             {TRUE}
   19 00000000         ;****************************************************************
   20 00000000         ;Include files
   21 00000000                 GET              MKL46Z4.s   ;Included by start.s
   23 00000000         ;****************************************************************
   24 00000000         ;EQUates
   25 00000000         ;---------------------------------------------------------------
   26 00000000         ;NVIC_ICER
   27 00000000         ;31-00:CLRENA=masks for HW IRQ sources;
   28 00000000         ;             read:   0 = unmasked;   1 = masked
   29 00000000         ;             write:  0 = no effect;  1 = mask
   30 00000000         ;12:UART0 IRQ mask
   31 00000000 00001000 
                       NVIC_ICER_UART0_MASK
                               EQU              UART0_IRQ_MASK
   32 00000000         ;---------------------------------------------------------------
   33 00000000         ;NVIC_ICPR
   34 00000000         ;31-00:CLRPEND=pending status for HW IRQ sources;
   35 00000000         ;             read:   0 = not pending;  1 = pending
   36 00000000         ;             write:  0 = no effect;
   37 00000000         ;                     1 = change status to not pending
   38 00000000         ;12:UART0 IRQ pending status
   39 00000000 00001000 



ARM Macro Assembler    Page 2 


                       NVIC_ICPR_UART0_MASK
                               EQU              UART0_IRQ_MASK
   40 00000000         ;---------------------------------------------------------------
   41 00000000         ;NVIC_IPR0-NVIC_IPR7
   42 00000000         ;2-bit priority:  00 = highest; 11 = lowest
   43 00000000 00000003 
                       UART0_IRQ_PRIORITY
                               EQU              3
   44 00000000 000000C0 
                       NVIC_IPR_UART0_MASK
                               EQU              (3 << UART0_PRI_POS)
   45 00000000 000000C0 
                       NVIC_IPR_UART0_PRI_3
                               EQU              (UART0_IRQ_PRIORITY << UART0_PRI_POS)
   46 00000000         ;---------------------------------------------------------------
   47 00000000         ;NVIC_ISER
   48 00000000         ;31-00:SETENA=masks for HW IRQ sources;
   49 00000000         ;             read:   0 = masked;     1 = unmasked
   50 00000000         ;             write:  0 = no effect;  1 = unmask
   51 00000000         ;12:UART0 IRQ mask
   52 00000000 00001000 
                       NVIC_ISER_UART0_MASK
                               EQU              UART0_IRQ_MASK
   53 00000000         ;---------------------------------------------------------------
   54 00000000         ;PORTx_PCRn (Port x pin control register n [for pin n])
   55 00000000         ;___->10-08:Pin mux control (select 0 to 8)
   56 00000000         ;Use provided PORT_PCR_MUX_SELECT_2_MASK
   57 00000000         ;---------------------------------------------------------------
   58 00000000         ;Port A
   60 00000000 01000200 
                       PORT_PCR_SET_PTA1_UART0_RX
                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   62 00000000 01000200 
                       PORT_PCR_SET_PTA2_UART0_TX
                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   63 00000000         ;---------------------------------------------------------------
   64 00000000         ;SIM_SCGC4
   65 00000000         ;1->10:UART0 clock gate control (enabled)
   66 00000000         ;Use provided SIM_SCGC4_UART0_MASK
   67 00000000         ;---------------------------------------------------------------



ARM Macro Assembler    Page 3 


   68 00000000         ;SIM_SCGC5
   69 00000000         ;1->09:Port A clock gate control (enabled)
   70 00000000         ;Use provided SIM_SCGC5_PORTA_MASK
   71 00000000         ;---------------------------------------------------------------
   72 00000000         ;SIM_SOPT2
   73 00000000         ;01=27-26:UART0SRC=UART0 clock source select
   74 00000000         ;         (PLLFLLSEL determines MCGFLLCLK' or MCGPLLCLK/2)
   75 00000000         ; 1=   16:PLLFLLSEL=PLL/FLL clock select (MCGPLLCLK/2)
   77 00000000 04000000 
                       SIM_SOPT2_UART0SRC_MCGPLLCLK
                               EQU              (1 << SIM_SOPT2_UART0SRC_SHIFT)
   79 00000000 04010000 
                       SIM_SOPT2_UART0_MCGPLLCLK_DIV2
                               EQU              (SIM_SOPT2_UART0SRC_MCGPLLCLK :OR: SIM_SOPT2_PLLFLLSEL_MASK)
   80 00000000         ;---------------------------------------------------------------
   81 00000000         ;SIM_SOPT5
   82 00000000         ; 0->   16:UART0 open drain enable (disabled)
   83 00000000         ; 0->   02:UART0 receive data select (UART0_RX)
   84 00000000         ;00->01-00:UART0 transmit data select source (UART0_TX)
   88 00000000 00010007 
                       SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
                               EQU              (SIM_SOPT5_UART0ODE_MASK :OR:                                  SIM_SOPT
5_UART0RXSRC_MASK :OR:                                  SIM_SOPT5_UART0TXSRC_MASK)
   89 00000000         ;---------------------------------------------------------------
   90 00000000         ;UART0_BDH
   91 00000000         ;    0->  7:LIN break detect IE (disabled)
   92 00000000         ;    0->  6:RxD input active edge IE (disabled)
   93 00000000         ;    0->  5:Stop bit number select (1)
   94 00000000         ;00001->4-0:SBR[12:0] (UART0CLK / [9600 * (OSR + 1)]) 
   95 00000000         ;UART0CLK is MCGPLLCLK/2
   96 00000000         ;MCGPLLCLK is 96 MHz
   97 00000000         ;MCGPLLCLK/2 is 48 MHz
   98 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   99 00000000 00000001 
                       UART0_BDH_9600
                               EQU              0x01
  100 00000000         ;---------------------------------------------------------------
  101 00000000         ;UART0_BDL
  102 00000000         ;26->7-0:SBR[7:0] (UART0CLK / [9600 * (OSR + 1)])
  103 00000000         ;UART0CLK is MCGPLLCLK/2
  104 00000000         ;MCGPLLCLK is 96 MHz
  105 00000000         ;MCGPLLCLK/2 is 48 MHz



ARM Macro Assembler    Page 4 


  106 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
  107 00000000 00000038 
                       UART0_BDL_9600
                               EQU              0x38
  108 00000000         ;---------------------------------------------------------------
  109 00000000         ;UART0_C1
  110 00000000         ;0-->7:LOOPS=loops select (normal)
  111 00000000         ;0-->6:DOZEEN=doze enable (disabled)
  112 00000000         ;0-->5:RSRC=receiver source select (internal--no effect LOOPS=0)
  113 00000000         ;0-->4:M=9- or 8-bit mode select 
  114 00000000         ;        (1 start, 8 data [lsb first], 1 stop)
  115 00000000         ;0-->3:WAKE=receiver wakeup method select (idle)
  116 00000000         ;0-->2:IDLE=idle line type select (idle begins after start bit)
  117 00000000         ;0-->1:PE=parity enable (disabled)
  118 00000000         ;0-->0:PT=parity type (even parity--no effect PE=0)
  119 00000000 00000000 
                       UART0_C1_8N1
                               EQU              0x00
  120 00000000         ;---------------------------------------------------------------
  121 00000000         ;UART0_C2
  122 00000000         ;0-->7:TIE=transmit IE for TDRE (disabled)
  123 00000000         ;0-->6:TCIE=transmission complete IE for TC (disabled)
  124 00000000         ;0-->5:RIE=receiver IE for RDRF (disabled)
  125 00000000         ;0-->4:ILIE=idle line IE for IDLE (disabled)
  126 00000000         ;1-->3:TE=transmitter enable (enabled)
  127 00000000         ;1-->2:RE=receiver enable (enabled)
  128 00000000         ;0-->1:RWU=receiver wakeup control (normal)
  129 00000000         ;0-->0:SBK=send break (disabled, normal)
  130 00000000 0000000C 
                       UART0_C2_T_R
                               EQU              (UART0_C2_TE_MASK :OR: UART0_C2_RE_MASK)
  131 00000000 0000002C 
                       UART0_C2_T_RI
                               EQU              (UART0_C2_RIE_MASK :OR: UART0_C2_T_R)
  132 00000000 000000AC 
                       UART0_C2_TI_RI
                               EQU              (UART0_C2_TIE_MASK :OR: UART0_C2_T_RI)
  133 00000000         ;---------------------------------------------------------------
  134 00000000         ;UART0_C3
  135 00000000         ;0-->7:R8T9=9th data bit for receiver (not used M=0)
  136 00000000         ;           10th data bit for transmitter (not used M10=0)
  137 00000000         ;0-->6:R9T8=9th data bit for transmitter (not used M=0)



ARM Macro Assembler    Page 5 


  138 00000000         ;           10th data bit for receiver (not used M10=0)
  139 00000000         ;0-->5:TXDIR=UART_TX pin direction in single-wire mode
  140 00000000         ;            (no effect LOOPS=0)
  141 00000000         ;0-->4:TXINV=transmit data inversion (not inverted)
  142 00000000         ;0-->3:ORIE=overrun IE for OR (disabled)
  143 00000000         ;0-->2:NEIE=noise error IE for NF (disabled)
  144 00000000         ;0-->1:FEIE=framing error IE for FE (disabled)
  145 00000000         ;0-->0:PEIE=parity error IE for PF (disabled)
  146 00000000 00000000 
                       UART0_C3_NO_TXINV
                               EQU              0x00
  147 00000000         ;---------------------------------------------------------------
  148 00000000         ;UART0_C4
  149 00000000         ;    0-->  7:MAEN1=match address mode enable 1 (disabled)
  150 00000000         ;    0-->  6:MAEN2=match address mode enable 2 (disabled)
  151 00000000         ;    0-->  5:M10=10-bit mode select (not selected)
  152 00000000         ;01111-->4-0:OSR=over sampling ratio (16)
  153 00000000         ;               = 1 + OSR for 3 <= OSR <= 31
  154 00000000         ;               = 16 for 0 <= OSR <= 2 (invalid values)
  155 00000000 0000000F 
                       UART0_C4_OSR_16
                               EQU              0x0F
  156 00000000 0000000F 
                       UART0_C4_NO_MATCH_OSR_16
                               EQU              UART0_C4_OSR_16
  157 00000000         ;---------------------------------------------------------------
  158 00000000         ;UART0_C5
  159 00000000         ;  0-->  7:TDMAE=transmitter DMA enable (disabled)
  160 00000000         ;  0-->  6:Reserved; read-only; always 0
  161 00000000         ;  0-->  5:RDMAE=receiver full DMA enable (disabled)
  162 00000000         ;000-->4-2:Reserved; read-only; always 0
  163 00000000         ;  0-->  1:BOTHEDGE=both edge sampling (rising edge only)
  164 00000000         ;  0-->  0:RESYNCDIS=resynchronization disable (enabled)
  165 00000000 00000000 
                       UART0_C5_NO_DMA_SSR_SYNC
                               EQU              0x00
  166 00000000         ;---------------------------------------------------------------
  167 00000000         ;UART0_S1
  168 00000000         ;0-->7:TDRE=transmit data register empty flag; read-only
  169 00000000         ;0-->6:TC=transmission complete flag; read-only
  170 00000000         ;0-->5:RDRF=receive data register full flag; read-only
  171 00000000         ;1-->4:IDLE=idle line flag; write 1 to clear (clear)



ARM Macro Assembler    Page 6 


  172 00000000         ;1-->3:OR=receiver overrun flag; write 1 to clear (clear)
  173 00000000         ;1-->2:NF=noise flag; write 1 to clear (clear)
  174 00000000         ;1-->1:FE=framing error flag; write 1 to clear (clear)
  175 00000000         ;1-->0:PF=parity error flag; write 1 to clear (clear)
  176 00000000 0000001F 
                       UART0_S1_CLEAR_FLAGS
                               EQU              0x1F
  177 00000000         ;---------------------------------------------------------------
  178 00000000         ;UART0_S2
  179 00000000         ;1-->7:LBKDIF=LIN break detect interrupt flag (clear)
  180 00000000         ;             write 1 to clear
  181 00000000         ;1-->6:RXEDGIF=RxD pin active edge interrupt flag (clear)
  182 00000000         ;              write 1 to clear
  183 00000000         ;0-->5:(reserved); read-only; always 0
  184 00000000         ;0-->4:RXINV=receive data inversion (disabled)
  185 00000000         ;0-->3:RWUID=receive wake-up idle detect
  186 00000000         ;0-->2:BRK13=break character generation length (10)
  187 00000000         ;0-->1:LBKDE=LIN break detect enable (disabled)
  188 00000000         ;0-->0:RAF=receiver active flag; read-only
  189 00000000 000000C0 
                       UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
                               EQU              0xC0
  190 00000000         ;---------------------------------------------------------------
  191 00000000         ;Same old stuff 
  192 00000000 00000004 
                       Q_BUF_SZ
                               EQU              4
  193 00000000 00000012 
                       Q_REC_SZ
                               EQU              18
  194 00000000 0000004F 
                       MAX_STRING
                               EQU              79
  195 00000000 00000050 
                       MAX_QUEUE
                               EQU              80
  196 00000000 00000000 
                       IN_PTR  EQU              0
  197 00000000 00000004 
                       OUT_PTR EQU              4
  198 00000000 00000008 
                       BUF_START



ARM Macro Assembler    Page 7 


                               EQU              8
  199 00000000 0000000C 
                       BUF_PAST
                               EQU              12
  200 00000000 00000010 
                       BUF_SIZE
                               EQU              16
  201 00000000 00000011 
                       NUM_ENQD
                               EQU              17
  202 00000000         
  203 00000000         ;Servo calibration values for lookup table
  204 00000000 0000EA60 
                       PWM_PERIOD_20ms
                               EQU              60000
  205 00000000 00000BB8 
                       PWM_DUTY_5
                               EQU              3000
  206 00000000 0000157C 
                       PWM_DUTY_10
                               EQU              5500
  207 00000000         
  208 00000000         ;DAC lookup table equates
  209 00000000 00001000 
                       DAC0_STEPS
                               EQU              4096
  210 00000000 00000005 
                       SERVO_POSITIONS
                               EQU              5
  211 00000000         ;****************************************************************
  212 00000000         ;Program
  213 00000000         ;C source will contain main ()
  214 00000000         ;Only subroutines and ISRs in this assembly source
  215 00000000                 AREA             MyCode,CODE,READONLY
  216 00000000                 EXPORT           PWM_duty_table_0
  217 00000000                 EXPORT           DAC0_table_0
  218 00000000                 EXPORT           GetStringSB
  219 00000000                 EXPORT           PutStringSB
  220 00000000                 EXPORT           Init_UART0_IRQ
  221 00000000                 EXPORT           AddIntMultiU
  222 00000000                 EXPORT           GetChar
  223 00000000                 EXPORT           PutChar



ARM Macro Assembler    Page 8 


  224 00000000                 EXPORT           PutNumHex
  225 00000000                 EXPORT           UART0_IRQHandler
  226 00000000         ;>>>>> begin subroutine code <<<<<
  227 00000000         ;This subroutine adds the n-word unsigned number in register R2 to 
  228 00000000         ;the n-word unsigned numbe rin register R1. The result
  229 00000000         ;is then stored in memory at address R0. The value located
  230 00000000         ;in R3 is the number of words of each number that will be added.
  231 00000000         ;R0 is then overwritten with either a 0 for success or the 
  232 00000000         ;value of 1 for failure (overflow)
  233 00000000         ;Load in values one word (register) at a time
  234 00000000         ;And add using ADCS to utilize the state of the ASPR c 
  235 00000000         ;bit when carrying operations over.
  236 00000000         ;Inputs:
  237 00000000         ;R0 = mem address to store result added number
  238 00000000         ;R1 = mem address of number 1 to add
  239 00000000         ;R2 = mem address of number 2 to add
  240 00000000         ;R3 = size (number of words) that numbers in R1 and R2 coorespond to
  241 00000000         ;Outputs
  242 00000000         ;R0 = Status value (0 for success and 1 for overflow)
  243 00000000         AddIntMultiU
  244 00000000 B4FE            PUSH             {R1-R7}
  245 00000002 2500            MOVS             R5,#0       ;Initalize offset to 0
  246 00000004 2404            MOVS             R4,#4
  247 00000006 4363            MULS             R3,R4,R3    ;Multiply words by 4 to compare
  248 00000008 1C2D            ADDS             R5,R5,#0    ; clears c flag
  249 0000000A F3EF 8400       MRS              R4,APSR     ;Preserves APSR
  250 0000000E         AddIntMultiUloop
  251 0000000E 594E            LDR              R6,[R1,R5]  ;Load first number
  252 00000010 5957            LDR              R7,[R2,R5]  ;Load second number
  253 00000012 F384 8800       MSR              APSR,R4     ;Restore APSR
  254 00000016 417E            ADCS             R6,R6,R7
  255 00000018 5146            STR              R6,[R0,R5]  ;Store the result
  256 0000001A F3EF 8400       MRS              R4,APSR     ;Preserve APSR
  257 0000001E 1D2D            ADDS             R5,R5,#4    ;Increment Offset
  258 00000020 42AB            CMP              R3,R5
  259 00000022 D003            BEQ              EndAddIntMultiUloop
  260 00000024 E7F3            B                AddIntMultiUloop ;Continue adding
  261 00000026         
  262 00000026         CheckForOverflow
  263 00000026 2001            MOVS             R0,#1       ;Signal overlflow by settin R1
  264 00000028 BCFE            POP              {R1-R7}     ;Restore values
  265 0000002A 4770            BX               LR



ARM Macro Assembler    Page 9 


  266 0000002C         
  267 0000002C         EndAddIntMultiUloop
  268 0000002C F384 8800       MSR              APSR,R4
  269 00000030 D2F9            BCS              CheckForOverflow ;If carry set then theres overflow
  270 00000032 2000            MOVS             R0,#0
  271 00000034 BCFE            POP              {R1-R7}     ;Restore values
  272 00000036 4770            BX               LR
  273 00000038         
  274 00000038         
  275 00000038         ;UART0 Interrupt Service routine. Checks what triggered ISR and acts accordingly.
  276 00000038         ;subroutines: Dequeue, Enqueue
  277 00000038         ;   Inputs:   none
  278 00000038         ;   Outputs:  none
  279 00000038         ;   Modify:   none
  280 00000038         UART0_IRQHandler
  281 00000038         UART0_ISR
  282 00000038 B672            CPSID            I           ; mask interrupts
  283 0000003A B500            PUSH             {LR}        ; preserve link register
  284 0000003C B430            PUSH             {R4,R5}     ; preserve registers
  285 0000003E 49A5            LDR              R1,=UART0_BASE ; base address
  286 00000040         ;Interrupt source can be found in UART0_S1
  287 00000040 78CC    checkTX LDRB             R4,[R1,#UART0_C2_OFFSET] ; loads current UART0 C2 settings
  288 00000042 2580            MOVS             R5,#UART0_C2_TIE_MASK ; Transmit Interrupt Enabled
  289 00000044 4025            ANDS             R5,R5,R4    ; turns off everything except pin 7, if it was on to begin w
                                                            ith
  290 00000046 D00D            BEQ              checkRX     ; if  pin 7 was off, TX interrupt is disabled
  291 00000048 790C            LDRB             R4,[R1,#UART0_S1_OFFSET] ; load S1 to check TDRE
  292 0000004A 2580            MOVS             R5,#UART0_S1_TDRE_MASK ; load tdre mask
  293 0000004C 402C            ANDS             R4,R4,R5
  294 0000004E D009            BEQ              checkRX     ; if not, check receive!
  295 00000050         ;otherwise, it is set! Let's dequeue character from TxQBuffer
  296 00000050 49A1            LDR              R1,=TxQueueRecord
  297 00000052 F000 F831       BL               Dequeue
  298 00000056 D202            BCS              ISRtxfail   ; if the dequeue failed (BUFFER IS EMPTY), branch! otherwise
                                                            , run
  299 00000058         ; If it succeeded, write character to UART0 transmit data reg.
  300 00000058 499E            LDR              R1,=UART0_BASE ; base address
  301 0000005A 71C8            STRB             R0,[R1,#UART0_D_OFFSET] ; stores character from dequeue
  302 0000005C E002            B                checkRX     ; quit
  303 0000005E         ISRtxfail                            ; if TxQBuffer is empty, disable Tx
  304 0000005E 499D            LDR              R1,=UART0_BASE ; base address
  305 00000060 4C9E            LDR              R4,=UART0_C2_T_RI ; address of value to store



ARM Macro Assembler    Page 10 


  306 00000062 70CC            STRB             R4,[R1,#UART0_C2_OFFSET] ; offset for transmit/recieve
  307 00000064 790C    checkRX LDRB             R4,[R1,#UART0_S1_OFFSET]
  308 00000066 2520            MOVS             R5,#UART0_S1_RDRF_MASK
  309 00000068 4025            ANDS             R5,R5,R4
  310 0000006A D003            BEQ              ISRend      ; if not, get out!
  311 0000006C         ; otherwise, let's enqueue this character
  312 0000006C 79C8            LDRB             R0,[R1,#UART0_D_OFFSET] ; gets character from data recieve register
  313 0000006E 499C            LDR              R1,=RxQueueRecord ; sets queue to enqueue into as RxQRecord
  314 00000070 F000 F842       BL               Enqueue     ; enqueues the character from R0 into RxQRecord
  315 00000074         ; character is lost if RxQueue is full
  316 00000074 BC30    ISRend  POP              {R4,R5}     ; restore registers
  317 00000076 B662            CPSIE            I           ; unmask interrupts
  318 00000078 BD00            POP              {PC}        ; return to where it was called from
  319 0000007A         
  320 0000007A         ;This subroutine prints  the hex representation of a value
  321 0000007A         ;in r0 to the console
  322 0000007A         ;Inputs:
  323 0000007A         ; R0 - Value to print to the screen
  324 0000007A         ;Outputs
  325 0000007A         ; None
  326 0000007A         PutNumHex
  327 0000007A B51C            PUSH             {R2,R3,R4,LR}
  328 0000007C 2220            MOVS             R2,#32      ;Initialize counter
  329 0000007E         PutNumHexLoop
  330 0000007E 2A00            CMP              R2,#0       ;Compare counter to 0
  331 00000080 DB10            BLT              EndPutNumHex
  332 00000082 0003            MOVS             R3,R0       ;Move value tp r3
  333 00000084 240F            MOVS             R4,#0x0F    ;Value to shift
  334 00000086 40D3            LSRS             R3,R2       ;Shift to right most 
  335 00000088 401C            ANDS             R4,R4,R3    ;Mask 
  336 0000008A 2C0A            CMP              R4,#10      ;Compare to ascii
  337 0000008C DA01            BGE              PrintLetter ;Its a letter        
  338 0000008E 3430            ADDS             R4,#'0'     ;Its a number so print number
  339 00000090 E000            B                PrintNumber
  340 00000092         PrintLetter
  341 00000092 3437            ADDS             R4,R4,#55   ;Convert to ascii     
  342 00000094         PrintNumber
  343 00000094 B401            PUSH             {R0}        ;Save R0 value
  344 00000096 0020            MOVS             R0,R4       ;Initialize for put char
  345 00000098 F7FF FFFE       BL               PutChar
  346 0000009C BC01            POP              {R0}        ;Restore original value
  347 0000009E         ;Reset value in R3 and increment loop counter



ARM Macro Assembler    Page 11 


  348 0000009E 2400            MOVS             R4,#0       ;Reset R4
  349 000000A0 1F12            SUBS             R2,R2,#4    ;Decrement counter
  350 000000A2 E7EC            B                PutNumHexLoop
  351 000000A4         EndPutNumHex
  352 000000A4 BD1C            POP              {R2,R3,R4,PC}
  353 000000A6         
  354 000000A6         ;This subroutine initializes an empty queue
  355 000000A6         ;Input parameters:
  356 000000A6         ;   R0, queue buffer address 
  357 000000A6         ;   R1, queue record structure
  358 000000A6         ; R2, queue size
  359 000000A6         ;Output parameters:
  360 000000A6         ;   None 
  361 000000A6         ;Modified Registers
  362 000000A6         ; None 
  363 000000A6         InitQueue
  364 000000A6 6008            STR              R0,[R1,#IN_PTR] ;Initialize In pointer to start of queue
  365 000000A8 6048            STR              R0,[R1,#OUT_PTR] ;Initialize Out pointer to start of queue
  366 000000AA 6088            STR              R0,[R1,#BUF_START] ;Initialize buffer start to start of queue
  367 000000AC 1880            ADDS             R0,R0,R2    ;Add buff start to queue size
  368 000000AE 60C8            STR              R0,[R1,#BUF_PAST] ;store as buff past
  369 000000B0 610A            STR              R2,[R1,#BUF_SIZE] ;Store queue size as buff size
  370 000000B2 2000            MOVS             R0,#0       ;Initialize num enqd as zero
  371 000000B4 7448            STRB             R0,[R1,#NUM_ENQD] ;store num enqd 
  372 000000B6 4770            BX               LR
  373 000000B8         
  374 000000B8         ;This subroutine dequeues a character
  375 000000B8         ;Input paramters:
  376 000000B8         ; R1: Address of queue record structure
  377 000000B8         ;Output:
  378 000000B8         ; PSR C flag: success(0) or failure (1)
  379 000000B8         ; r0: Character to dequeued 
  380 000000B8         ;Modify: PSR
  381 000000B8         Dequeue
  382 000000B8 B478            PUSH             {R3-R6}
  383 000000BA 7C4B            LDRB             R3,[R1,#NUM_ENQD] ;get number enqueued
  384 000000BC 2B00            CMP              R3,#0       ;Compare num enqued and 0
  385 000000BE D011            BEQ              QueueEmpty  ;Branch if num enqd =< 0
  386 000000C0 684D            LDR              R5,[R1,#OUT_PTR] ;get adress of outpointer
  387 000000C2 68CE            LDR              R6,[R1,#BUF_PAST] ;Load buffer past
  388 000000C4 7828            LDRB             R0,[R5,#0]  ;Load actual value from queue
  389 000000C6 1E5B            SUBS             R3,R3,#1    ;Decrement num enqd



ARM Macro Assembler    Page 12 


  390 000000C8 744B            STRB             R3,[R1,#NUM_ENQD] ;Store new num enqd value
  391 000000CA 1C6D            ADDS             R5,R5,#1    ;Increment outpointer
  392 000000CC 42B5            CMP              R5,R6       ;Compare to outpointer
  393 000000CE D300            BLO              ClearPSRDequeue
  394 000000D0 688D            LDR              R5,[R1,#BUF_START] ;Load buffewr start
  395 000000D2         
  396 000000D2         ClearPSRDequeue
  397 000000D2 604D            STR              R5,[R1,#OUT_PTR] ;Store buffer start as outpointer
  398 000000D4 F3EF 8300       MRS              R3,APSR     ;Clear the PSR C flag
  399 000000D8 2420            MOVS             R4,#0x20
  400 000000DA 0624            LSLS             R4,R4,#24
  401 000000DC 43A3            BICS             R3,R3,R4
  402 000000DE F383 8800       MSR              APSR,R3
  403 000000E2 E007            B                EndDequeue
  404 000000E4         QueueEmpty
  405 000000E4 F3EF 8300       MRS              R3,APSR     ;Set the PSR C flag
  406 000000E8 2420            MOVS             R4,#0x20
  407 000000EA 0624            LSLS             R4,R4,#24
  408 000000EC 4323            ORRS             R3,R3,R4
  409 000000EE F383 8800       MSR              APSR, R3
  410 000000F2 E7FF            B                EndDequeue
  411 000000F4         EndDequeue
  412 000000F4 BC78            POP              {R3-R6}
  413 000000F6 4770            BX               LR
  414 000000F8         
  415 000000F8         ;This subroutine enqueues a character
  416 000000F8         ;Input paramters:
  417 000000F8         ; r0: Character to enque 
  418 000000F8         ; R1: Address of queue record structure
  419 000000F8         ;Output:
  420 000000F8         ; PSR C flag: success(0) or failure (1)
  421 000000F8         ;Modify: PSR
  422 000000F8         
  423 000000F8         ;This subroutine enqueues a character
  424 000000F8         ;Input paramters:
  425 000000F8         ; r0: Character to enque 
  426 000000F8         ; R1: Address of queue record structure
  427 000000F8         ;Output:
  428 000000F8         ; PSR C flag: success(0) or failure (1)
  429 000000F8         ;Modify: PSR
  430 000000F8         Enqueue
  431 000000F8 B478            PUSH             {R3-R6}



ARM Macro Assembler    Page 13 


  432 000000FA 7C4B            LDRB             R3,[R1, #NUM_ENQD] ;Load number enqued
  433 000000FC 7C0C            LDRB             R4,[R1, #BUF_SIZE] ;Load buffer size
  434 000000FE 42A3            CMP              R3,R4       ;Compare
  435 00000100 DA11            BGE              QueueFull   ;If number enqd >= buffsize then Queue full
  436 00000102 680D            LDR              R5,[R1, #IN_PTR] ;Load inpointer
  437 00000104 68CE            LDR              R6,[R1,#BUF_PAST] ;Load buffer past
  438 00000106 7028            STRB             R0,[R5, #0] ;Store character at inpointer 
  439 00000108 1C5B            ADDS             R3,R3,#1    ;Increment inpointer
  440 0000010A 744B            STRB             R3,[R1,#NUM_ENQD] ;Store num enqd
  441 0000010C 1C6D            ADDS             R5,R5,#1    ;Increment num enqd
  442 0000010E 42B5            CMP              R5,R6       ;If inpointer >= buff past
  443 00000110 D300            BLO              SetCarry
  444 00000112 688D            LDR              R5,[R1,#BUF_START] ;Load buff start
  445 00000114         SetCarry
  446 00000114 600D            STR              R5,[R1,#IN_PTR] ;Store buff start as inpointer
  447 00000116 F3EF 8300       MRS              R3,APSR     ;Clear the PSR C flag 
  448 0000011A 2420            MOVS             R4,#0x20
  449 0000011C 0624            LSLS             R4,R4,#24
  450 0000011E 43A3            BICS             R3,R3,R4
  451 00000120 F383 8800       MSR              APSR,R3
  452 00000124 E006            B                EndEnqueue
  453 00000126         
  454 00000126         QueueFull
  455 00000126 F3EF 8300       MRS              R3,APSR     ;Set PSR C flag to 1  
  456 0000012A 2420            MOVS             R4,#0x20
  457 0000012C 0624            LSLS             R4,R4,#24
  458 0000012E 4323            ORRS             R3,R3,R4
  459 00000130 F383 8800       MSR              APSR,R3
  460 00000134         
  461 00000134         EndEnqueue
  462 00000134 BC78            POP              {R3-R6}
  463 00000136 4770            BX               LR
  464 00000138         
  465 00000138         ;This subroutine sends a character out of UART0 using interrupts
  466 00000138         ;Inputs
  467 00000138         ; R0 - Character to enqueue to TxQueue
  468 00000138         ;Return 
  469 00000138         ; None
  470 00000138         
  471 00000138         PutChar
  472 00000138 B506            PUSH             {R1,R2,LR}
  473 0000013A 4967            LDR              R1,=TxQueueRecord



ARM Macro Assembler    Page 14 


  474 0000013C         REPEAT_ENQ
  475 0000013C         ;Mask all other interrupts
  476 0000013C B672            CPSID            I
  477 0000013E         ;Critical section -> enqueue character
  478 0000013E         ;Enqueue character that's already in R0
  479 0000013E F7FF FFDB       BL               Enqueue
  480 00000142         ;Enable interrupts
  481 00000142 B662            CPSIE            I
  482 00000144 D2FA            BCS              REPEAT_ENQ
  483 00000146         ;Enable UART0 Transmitter, reciever, and rx interrupt
  484 00000146 4963            LDR              R1,=UART0_BASE
  485 00000148 22AC            MOVS             R2,#UART0_C2_TI_RI
  486 0000014A 70CA            STRB             R2,[R1,#UART0_C2_OFFSET]
  487 0000014C         ;Pop original register values off the stack
  488 0000014C BD06            POP              {R1,R2,PC}
  489 0000014E         
  490 0000014E         ;This subroutine receives a character from UART0 using interrupts
  491 0000014E         ;Inputs 
  492 0000014E         ; None
  493 0000014E         ;Return
  494 0000014E         ; R0 - Character dequeued from RxQueue
  495 0000014E         GetChar
  496 0000014E B502            PUSH             {R1,LR}     ; Push varibles on the stack to avoid loss
  497 00000150 4963            LDR              R1,=RxQueueRecord
  498 00000152         REPEAT_DEQ
  499 00000152         ;Mask all interrupts
  500 00000152 B672            CPSID            I
  501 00000154         ;Critical code section - dequeue
  502 00000154 F7FF FFB0       BL               Dequeue
  503 00000158         ;Re enable interrupts
  504 00000158 B662            CPSIE            I
  505 0000015A D2FA            BCS              REPEAT_DEQ
  506 0000015C BD02            POP              {R1,PC}
  507 0000015E         
  508 0000015E         ;The follwing subroutine reads a string of chars from the keyboard
  509 0000015E         ;and stores them in a string dtarting from R0. For each character 
  510 0000015E         ;up to R1-1 it echoes the character and when the carage character (13-10 0D-16)
  511 0000015E         ;is not recieved it null terminates the string. it then moves
  512 0000015E         ;the cursor to the begining of the next line
  513 0000015E         ;Input parameters:
  514 0000015E         ;   R1 one more than the oveflow buffer
  515 0000015E         ; R0 pointer to address of string 



ARM Macro Assembler    Page 15 


  516 0000015E         ;Output parameters:
  517 0000015E         ;   None
  518 0000015E         ;Modified Registers
  519 0000015E         ;   None. The original contents of the registers are restored 
  520 0000015E         ;                 
  521 0000015E         GetStringSB
  522 0000015E B50F            PUSH             {R0,R1,R2,R3,LR}
  523 00000160 2200            MOVS             R2,#0       ;Initalize string offset to zero
  524 00000162 1E49            SUBS             R1,R1,#1
  525 00000164         GetStringSBLoop
  526 00000164 B401            PUSH             {R0}        ;Push Pointer value on stack
  527 00000166 F7FF FFFE       BL               GetChar     ;Get next char
  528 0000016A 0003            MOVS             R3,R0       ;Move char to r3
  529 0000016C BC01            POP              {R0}        ;Return pointer value to R0
  530 0000016E 2B0D            CMP              R3,#13      ;Compare char to carrage return
  531 00000170 D00A            BEQ              EndGetStringSB
  532 00000172 2900            CMP              R1,#0       ;If there is no more character
  533 00000174 D0F6            BEQ              GetStringSBLoop
  534 00000176 B401            PUSH             {R0}        ;Save Pointer value on stack
  535 00000178 0018            MOVS             R0,R3       ;move char to r3 for putchar
  536 0000017A F7FF FFFE       BL               PutChar
  537 0000017E BC01            POP              {R0}        ;Restore pointer value to R0
  538 00000180 5483            STRB             R3,[R0,R2]  ;Store char at pointer with offset
  539 00000182 1E49            SUBS             R1,R1,#1    ;Decrement number of chars
  540 00000184 1C52            ADDS             R2,R2,#1    ;Increment offset
  541 00000186 E7ED            B                GetStringSBLoop
  542 00000188         EndGetStringSB
  543 00000188         
  544 00000188 2300            MOVS             R3,#0       ;null
  545 0000018A 5483            STRB             R3,[R0,R2]  ;null terminate
  546 0000018C BD0F            POP              {R0,R1,R2,R3,PC}
  547 0000018E         
  548 0000018E         ;Displays a null terminated string to the terminal screen from memory starting at R0 
  549 0000018E         ;Preventing overun of the buffer capacity specified by R1
  550 0000018E         ;Leaves cursor specified in R1
  551 0000018E         
  552 0000018E         PutStringSB
  553 0000018E B50F            PUSH             {R0-R3,LR}
  554 00000190         ;BL   LengthStringSB
  555 00000190         ;MOVS  R1,R2
  556 00000190         ReadChar
  557 00000190 2900            CMP              R1,#0       ;If string is empty



ARM Macro Assembler    Page 16 


  558 00000192 D00A            BEQ              EndPutStringSB
  559 00000194 7803            LDRB             R3,[R0,#0]  ;Put char in R3
  560 00000196 2B00            CMP              R3,#0x00    ;Check if null
  561 00000198 D007            BEQ              EndPutStringSB ;End if null
  562 0000019A B401            PUSH             {R0}
  563 0000019C 0018            MOVS             R0,R3
  564 0000019E F7FF FFFE       BL               PutChar
  565 000001A2 BC01            POP              {R0}
  566 000001A4 1E49            SUBS             R1,R1,#1    ;Decrement number of chars
  567 000001A6 1C40            ADDS             R0,R0,#1    ;Increment offset
  568 000001A8 E7F2            B                ReadChar
  569 000001AA         EndPutStringSB
  570 000001AA BD0F            POP              {R0-R3,PC}
  571 000001AC         
  572 000001AC         ;Determines how many characters are in a a null terminated string
  573 000001AC         ;Memory of string starts in R0 and returns number of characters in R2
  574 000001AC         ;Prevents overrun of of buffer capacity specified in R1
  575 000001AC         ;
  576 000001AC         ;Input parameters:
  577 000001AC         ; R0 pointer to address of string 
  578 000001AC         ;Output parameters:
  579 000001AC         ;   R1: number of characters in String
  580 000001AC         ;Modified Registers
  581 000001AC         ;   None. The original contents of the registers are restored 
  582 000001AC         ;
  583 000001AC         
  584 000001AC         LengthStringSB
  585 000001AC B51D            PUSH             {R0,R2,R3,R4,LR}
  586 000001AE 214F            MOVS             R1,#MAX_STRING
  587 000001B0 2200            MOVS             R2,#0       ;Initalize length to 0
  588 000001B2 2400            MOVS             R4,#0       ;Initalize offset to 0
  589 000001B4         LengthStringSBLoop
  590 000001B4 428A            CMP              R2,R1       ;Compare Max_String to 0
  591 000001B6 DA05            BGE              EndLengthStringSB ;If Max_string < 0
  592 000001B8 5D03            LDRB             R3,[R0,R4]  ;Load first character in string
  593 000001BA 2B00            CMP              R3,#0       ;Compare char to 0
  594 000001BC D002            BEQ              EndLengthStringSB ;If null terminated then end
  595 000001BE 1C64            ADDS             R4,R4,#1    ;Increment offset
  596 000001C0 1C52            ADDS             R2,R2,#1    ;Increment lenghth 
  597 000001C2 E7F7            B                LengthStringSBLoop
  598 000001C4         EndLengthStringSB
  599 000001C4 BD1D            POP              {R0,R2,R3,R4,PC}



ARM Macro Assembler    Page 17 


  600 000001C6         
  601 000001C6         ;Stuff  
  602 000001C6         DIVU
  603 000001C6 B404            PUSH             {R2}        ;store R2 Value
  604 000001C8 2200            MOVS             R2,#0       ;move 0 to R2 for quotient
  605 000001CA 2800            CMP              R0,#0       ;Compare divisor to 0
  606 000001CC D010            BEQ              SETCARRY    ;if divisor = 0 go to SETCARRY
  607 000001CE         WHILE
  608 000001CE 4281            CMP              R1,R0       ;Compare R1 to R0
  609 000001D0 D302            BLO              ENDWHILE    ;if dividend<Divisor End loop
  610 000001D2 1C52            ADDS             R2,R2,#1    ;Add 1 to quotient
  611 000001D4 1A09            SUBS             R1,R1,R0    ;Dividend - divisor
  612 000001D6 E7FA            B                WHILE       ;branch to start of while  
  613 000001D8         ENDWHILE
  614 000001D8 0010            MOVS             R0,R2       ;move quotient to R0, so R0 remainder R1
  615 000001DA BC04            POP              {R2}        ;revert R2 to value before subroutine
  616 000001DC B403            PUSH             {R0,R1}     ;push R0 and R1
  617 000001DE F3EF 8000       MRS              R0,APSR     ;Set C flag to 0
  618 000001E2 2120            MOVS             R1,#0x20    ;
  619 000001E4 0609            LSLS             R1,#24      ;Shift 24 places (to most significant byte)
  620 000001E6 4388            BICS             R0,R0,R1    ; 
  621 000001E8 F380 8800       MSR              APSR,R0     ; 
  622 000001EC BC03            POP              {R0,R1}     ;revert R0 and R1 to answer 
  623 000001EE 4770            BX               LR          ;Go back to program
  624 000001F0         SETCARRY
  625 000001F0 BC04            POP              {R2}        ;Pop R2
  626 000001F2 B403            PUSH             {R0,R1}     ;Store R0 and R1
  627 000001F4 F3EF 8000       MRS              R0,APSR     ;Set C flag to 1
  628 000001F8 2120            MOVS             R1,#0x20    ;
  629 000001FA 0609            LSLS             R1,#24      ;Shift 24 places (to most significant byte)
  630 000001FC 4308            ORRS             R0,R0,R1    ;
  631 000001FE F380 8800       MSR              APSR,R0     ;
  632 00000202 BC03            POP              {R0,R1}     ;Revert R0 and R1 to answer
  633 00000204 4770            BX               LR
  634 00000206         Init_UART0_IRQ
  635 00000206         ;Initalize UART0 for Serial Driver
  636 00000206         ;Allocate R0-2 for Ri=k 
  637 00000206         ;Store prevoius values for restoration
  638 00000206 B50F            PUSH             {R0, R1, R2, R3, LR}
  639 00000208         ;Initalize rxQueue
  640 00000208 4935            LDR              R1, =RxQueueRecord
  641 0000020A 4836            LDR              R0, =RxQueue



ARM Macro Assembler    Page 18 


  642 0000020C 2204            MOVS             R2, #Q_BUF_SZ
  643 0000020E F7FF FF4A       BL               InitQueue
  644 00000212 4931            LDR              R1, =TxQueueRecord
  645 00000214 4834            LDR              R0, =TxQueue
  646 00000216 2204            MOVS             R2, #Q_BUF_SZ
  647 00000218 F7FF FF45       BL               InitQueue
  648 0000021C         ;Select MCGPLLCLK / 2 as UART0 clock source
  649 0000021C 4837            LDR              R0,=SIM_SOPT2
  650 0000021E 4938            LDR              R1,=SIM_SOPT2_UART0SRC_MASK
  651 00000220 6802            LDR              R2,[R0,#0]
  652 00000222 438A            BICS             R2,R2,R1
  653 00000224 4937            LDR              R1,=SIM_SOPT2_UART0_MCGPLLCLK_DIV2
  654 00000226 430A            ORRS             R2,R2,R1
  655 00000228 6002            STR              R2,[R0,#0]
  656 0000022A         ;Enable external connection for UART0
  657 0000022A 4837            LDR              R0,=SIM_SOPT5
  658 0000022C 4937            LDR              R1,=SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
  659 0000022E 6802            LDR              R2,[R0,#0]
  660 00000230 438A            BICS             R2,R2,R1
  661 00000232 6002            STR              R2,[R0,#0]
  662 00000234         ;Enable clock for UART0 module 
  663 00000234 4836            LDR              R0,=SIM_SCGC4
  664 00000236 4937            LDR              R1,=SIM_SCGC4_UART0_MASK
  665 00000238 6802            LDR              R2,[R0,#0]
  666 0000023A 430A            ORRS             R2,R2,R1
  667 0000023C 6002            STR              R2,[R0,#0]
  668 0000023E         ;Enable clock for Port A module
  669 0000023E 4836            LDR              R0,=SIM_SCGC5
  670 00000240 4936            LDR              R1,=SIM_SCGC5_PORTA_MASK
  671 00000242 6802            LDR              R2,[R0,#0]
  672 00000244 430A            ORRS             R2,R2,R1
  673 00000246 6002            STR              R2,[R0,#0]
  674 00000248         ;Connect PORT A Pin 1 (PTA1) to UART0 Rx (J1 Pin 02)
  675 00000248 4835            LDR              R0,=PORTA_PCR1
  676 0000024A 4936            LDR              R1,=PORT_PCR_SET_PTA1_UART0_RX
  677 0000024C 6001            STR              R1,[R0,#0]
  678 0000024E         ;Connect PORT A Pin 2 (PTA2) to UART0 Tx (J1 Pin 04)
  679 0000024E 4836            LDR              R0,=PORTA_PCR2
  680 00000250 4934            LDR              R1,=PORT_PCR_SET_PTA2_UART0_TX
  681 00000252 6001            STR              R1,[R0,#0]
  682 00000254         ;Disable UART0 receiver and transmitter
  683 00000254 481F            LDR              R0,=UART0_BASE



ARM Macro Assembler    Page 19 


  684 00000256 210C            MOVS             R1,#UART0_C2_T_R
  685 00000258 78C2            LDRB             R2,[R0,#UART0_C2_OFFSET]
  686 0000025A 438A            BICS             R2,R2,R1
  687 0000025C 70C2            STRB             R2,[R0,#UART0_C2_OFFSET]
  688 0000025E         ;set UART0 IRQ priority
  689 0000025E 4833            LDR              R0,=UART0_IPR
  690 00000260         ;LDR R1,=NVIC_IPR_UART0_MASK
  691 00000260 4A33            LDR              R2,=NVIC_IPR_UART0_PRI_3
  692 00000262 6803            LDR              R3,[R0,#0]
  693 00000264         ;BICS R3,R3,R1
  694 00000264 4313            ORRS             R3,R3,R2
  695 00000266 6003            STR              R3,[R0,#0]
  696 00000268         ;clear any pending UART0 interrupts
  697 00000268 4832            LDR              R0,=NVIC_ICPR
  698 0000026A 4933            LDR              R1,=NVIC_ICPR_UART0_MASK
  699 0000026C 6001            STR              R1,[R0,#0]
  700 0000026E         ;Unmask UART0 interrupts
  701 0000026E 4833            LDR              R0,=NVIC_ISER
  702 00000270 4931            LDR              R1,=NVIC_ISER_UART0_MASK
  703 00000272 6001            STR              R1,[R0,#0]
  704 00000274         ;Set UART0 for 9600 baud, 8N1 protocol
  705 00000274 4817            LDR              R0,=UART0_BASE
  706 00000276 2101            MOVS             R1,#UART0_BDH_9600
  707 00000278 7001            STRB             R1,[R0,#UART0_BDH_OFFSET]
  708 0000027A 2138            MOVS             R1,#UART0_BDL_9600
  709 0000027C 7041            STRB             R1,[R0,#UART0_BDL_OFFSET]
  710 0000027E 2100            MOVS             R1,#UART0_C1_8N1
  711 00000280 7081            STRB             R1,[R0,#UART0_C1_OFFSET]
  712 00000282 2100            MOVS             R1,#UART0_C3_NO_TXINV
  713 00000284 7181            STRB             R1,[R0,#UART0_C3_OFFSET]
  714 00000286 210F            MOVS             R1,#UART0_C4_NO_MATCH_OSR_16
  715 00000288 7281            STRB             R1,[R0,#UART0_C4_OFFSET]
  716 0000028A 2100            MOVS             R1,#UART0_C5_NO_DMA_SSR_SYNC
  717 0000028C 72C1            STRB             R1,[R0,#UART0_C5_OFFSET]
  718 0000028E 211F            MOVS             R1,#UART0_S1_CLEAR_FLAGS
  719 00000290 7101            STRB             R1,[R0,#UART0_S1_OFFSET]
  720 00000292 21C0            MOVS             R1,#UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
  721 00000294 7141            STRB             R1,[R0,#UART0_S2_OFFSET]
  722 00000296         ;Enable UART0 receiver and transmitter
  723 00000296 212C            MOVS             R1,#UART0_C2_T_RI
  724 00000298 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  725 0000029A         ;Pop prevous R0-2 values off the stack.



ARM Macro Assembler    Page 20 


  726 0000029A BD0F            POP              {R0, R1, R2, R3, PC}
  727 0000029C         ;Prints the text in decimal of unsigned word value R0 in terminal screen
  728 0000029C         ;Using DivU
  729 0000029C         ;Input parameters:
  730 0000029C         ;   R0 is an Unsigned Word Value to print
  731 0000029C         ;Output parameters:
  732 0000029C         ;   None
  733 0000029C         ;Modified Registers
  734 0000029C         ;   PSR: (after return, nothing else)
  735 0000029C         PutNumU
  736 0000029C B507            PUSH             {R0,R1,R2,LR} ;Push registers as to not overwrite original values
  737 0000029E 2200            MOVS             R2,#0       ;Initialize offset 
  738 000002A0         DivideNumber
  739 000002A0 280A            CMP              R0,#10      ;Compare to 10, Div U divides by 10
  740 000002A2 DB09            BLT              PutNumUComplete ;If its less than 10, stop dividing
  741 000002A4 0001            MOVS             R1,R0       ;Initialize divided into R1
  742 000002A6 200A            MOVS             R0,#10      ;Initialize divisor to 10
  743 000002A8 F7FF FF8D       BL               DIVU        ;Divide!
  744 000002AC B401            PUSH             {R0}        ;Save R0's value
  745 000002AE 480F            LDR              R0,=StringReversal ;Reverse! Reverse!
  746 000002B0 5481            STRB             R1,[R0,R2]  ;Store in reversed string
  747 000002B2 1C52            ADDS             R2,R2,#1    ;Increment offset
  748 000002B4 BC01            POP              {R0}
  749 000002B6 E7F3            B                DivideNumber ;Keep looping until number is less than 10  
  750 000002B8         PutNumUComplete
  751 000002B8 3030            ADDS             R0,R0,#'0'  ;Convert to ascii 
  752 000002BA F7FF FFFE       BL               PutChar     ;Print it 
  753 000002BE 1E52            SUBS             R2,R2,#1    ;Decrement offset  
  754 000002C0         PutNumUPrintChar
  755 000002C0 480A            LDR              R0,=StringReversal ;Initialize pointer  
  756 000002C2 2A00            CMP              R2,#0       ;Compare to see if end is reached
  757 000002C4 DB05            BLT              PutNumUEnd  ;If at end of string then end
  758 000002C6 5C80            LDRB             R0,[R0,R2]  ;Get char
  759 000002C8 3030            ADDS             R0,R0,#'0'  ;Turn to ascii
  760 000002CA F7FF FFFE       BL               PutChar     ;Print
  761 000002CE 1E52            SUBS             R2,R2,#1    ;Decrement offset/counter
  762 000002D0 E7F6            B                PutNumUPrintChar ;Loop 
  763 000002D2         PutNumUEnd
  764 000002D2 BD07            POP              {R0,R1,R2,PC}
  765 000002D4         ;>>>>>   end subroutine code <<<<<
  766 000002D4                 ALIGN
  767 000002D4         ;**********************************************************************



ARM Macro Assembler    Page 21 


  768 000002D4         ;Constants
  769 000002D4 4006A000 
              00000000 
              0000002C 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              40048004 
              0C000000 
              04010000 
              40048010 
              00010007 
              40048034 
              00000400 
              40048038 
              00000200 
              40049004 
              01000200 
              40049008 
              E000E40C 
              000000C0 
              E000E280 
              00001000 
              E000E100 
              00000000 
              00000000         AREA             MyConst,DATA,READONLY
  770 00000000         ;>>>>> begin constants here <<<<<
  771 00000000         ;Lookup table for pulse width modulation values
  772 00000000         PWM_duty_table_0
  773 00000000 7C 15           DCW              PWM_DUTY_10 ;100% Range
  774 00000002 0B 13           DCW              ((3 * (PWM_DUTY_10 - PWM_DUTY_5)/4) + PWM_DUTY_5) ;75% Ramge
  775 00000004 9A 10           DCW              (((PWM_DUTY_10 - PWM_DUTY_5) / 2) + PWM_DUTY_5) ;50% Range
  776 00000006 29 0E           DCW              (((PWM_DUTY_10 - PWM_DUTY_5) / 4) + PWM_DUTY_5) ;25% Range
  777 00000008 B8 0B           DCW              PWM_DUTY_5  ;0% Range
  778 0000000A         
  779 0000000A 00 00           ALIGN
  780 0000000C         
  781 0000000C         ;Lookup table for conversion from integer input to appropriate value



ARM Macro Assembler    Page 22 


  782 0000000C         DAC0_table_0
  783 0000000C 99 01           DCW              ((DAC0_STEPS - 1) / (SERVO_POSITIONS * 2))
  784 0000000E CC 04           DCW              (((DAC0_STEPS - 1) * 3) / (SERVO_POSITIONS * 2))
  785 00000010 FF 07           DCW              (((DAC0_STEPS - 1) * 5) / (SERVO_POSITIONS * 2))
  786 00000012 32 0B           DCW              (((DAC0_STEPS - 1) * 7) / (SERVO_POSITIONS * 2))
  787 00000014 65 0E           DCW              (((DAC0_STEPS - 1) * 9) / (SERVO_POSITIONS * 2))
  788 00000016         ;>>>>>   end constants here <<<<<
  789 00000016         ;**********************************************************************
  790 00000016         ;Variables
  791 00000016                 AREA             MyData,DATA,READWRITE
  792 00000000         ;>>>>> begin variables here <<<<<
  793 00000000         ;Rx Queue
  794 00000000 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00    RxQueue SPACE            MAX_QUEUE
  795 00000050 00 00 00 
              00 00 00 
              00 00 00 



ARM Macro Assembler    Page 23 


              00 00 00 
              00 00 00 
              00 00 00 RxQueueRecord
                               SPACE            Q_REC_SZ
  796 00000062         
  797 00000062 00 00           ALIGN
  798 00000064         ;Tx Queue
  799 00000064 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00    TxQueue SPACE            MAX_QUEUE
  800 000000B4 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 TxQueueRecord
                               SPACE            Q_REC_SZ
  801 000000C6 00 00           ALIGN



ARM Macro Assembler    Page 24 


  802 000000C8         ;Queue 
  803 000000C8 00 00 00 
              00       Queue   SPACE            Q_BUF_SZ
  804 000000CC 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 QueueRecord
                               SPACE            Q_REC_SZ
  805 000000DE 00 00           ALIGN
  806 000000E0 00 00   StringReversal
                               SPACE            2
  807 000000E2 00 00           ALIGN
  808 000000E4 00 00   APSRState
                               SPACE            2
  809 000000E6 00 00           ALIGN
  810 000000E8 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 



ARM Macro Assembler    Page 25 


              00 00 00 
              00       InputString
                               SPACE            MAX_STRING
  811 00000137 00              ALIGN
  812 00000138         ;>>>>>   end variables here <<<<<
  813 00000138                 END
Command Line: --debug --length=49 --width=120 --diag_suppress=9931 --cpu=Cortex-M0+ --apcs=interwork --depend=.\objects\
exercise12_assembly.d -o.\objects\exercise12_assembly.o -ID:\Assembly\Exerciser12\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.
3.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.6.0\Device\Include --predefine="__UVISION_VERSION SETA 5
15" --predefine="_RTE_ SETA 1" --predefine="MKL46Z256xxx4 SETA 1" --list=.\listings\exercise12_assembly.lst Exercise12_A
ssembly.s
