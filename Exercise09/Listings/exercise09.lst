


ARM Macro Assembler    Page 1 Exercise 09 Serial I/O Driver


    1 00000000                 TTL              Exercise 09 Serial I/O Driver
    2 00000000         
    3 00000000         ;****************************************************************
    4 00000000         ;John Judge
    5 00000000         ;4/7/16
    6 00000000         ;Assembly
    7 00000000         ;---------------------------------------------------------------
    8 00000000         ;Keil Template for KL46
    9 00000000         ;R. W. Melton
   10 00000000         ;April 3, 2015
   11 00000000         ;****************************************************************
   12 00000000         ;Assembler directives
   13 00000000                 THUMB
   15 00000000         ;****************************************************************
   16 00000000         ;Include files
   17 00000000                 GET              MKL46Z4.s   ;Included by start.s
   19 00000000         ;****************************************************************
   20 00000000         ;EQUates
   21 00000000         ;---------------------------------------------------------------
   22 00000000         ;NVIC_ICER
   23 00000000         ;31-00:CLRENA=masks for HW IRQ sources;
   24 00000000         ;             read:   0 = unmasked;   1 = masked
   25 00000000         ;             write:  0 = no effect;  1 = mask
   26 00000000         ;12:UART0 IRQ mask
   27 00000000 00001000 
                       NVIC_ICER_UART0_MASK
                               EQU              UART0_IRQ_MASK
   28 00000000         ;---------------------------------------------------------------
   29 00000000         ;NVIC_ICPR
   30 00000000         ;31-00:CLRPEND=pending status for HW IRQ sources;
   31 00000000         ;             read:   0 = not pending;  1 = pending
   32 00000000         ;             write:  0 = no effect;
   33 00000000         ;                     1 = change status to not pending
   34 00000000         ;12:UART0 IRQ pending status
   35 00000000 00001000 
                       NVIC_ICPR_UART0_MASK
                               EQU              UART0_IRQ_MASK
   36 00000000         ;---------------------------------------------------------------
   37 00000000         ;NVIC_IPR0-NVIC_IPR7
   38 00000000         ;2-bit priority:  00 = highest; 11 = lowest
   39 00000000 00000003 
                       UART0_IRQ_PRIORITY



ARM Macro Assembler    Page 2 Exercise 09 Serial I/O Driver


                               EQU              3
   40 00000000 000000C0 
                       NVIC_IPR_UART0_MASK
                               EQU              (3 << UART0_PRI_POS)
   41 00000000 000000C0 
                       NVIC_IPR_UART0_PRI_3
                               EQU              (UART0_IRQ_PRIORITY << UART0_PRI_POS)
   42 00000000         ;---------------------------------------------------------------
   43 00000000         ;NVIC_ISER
   44 00000000         ;31-00:SETENA=masks for HW IRQ sources;
   45 00000000         ;             read:   0 = masked;     1 = unmasked
   46 00000000         ;             write:  0 = no effect;  1 = unmask
   47 00000000         ;12:UART0 IRQ mask
   48 00000000 00001000 
                       NVIC_ISER_UART0_MASK
                               EQU              UART0_IRQ_MASK
   49 00000000         ;---------------------------------------------------------------
   50 00000000         ;PORTx_PCRn (Port x pin control register n [for pin n])
   51 00000000         ;___->10-08:Pin mux control (select 0 to 8)
   52 00000000         ;Use provided PORT_PCR_MUX_SELECT_2_MASK
   53 00000000         ;---------------------------------------------------------------
   54 00000000         ;Port A
   56 00000000 01000200 
                       PORT_PCR_SET_PTA1_UART0_RX
                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   58 00000000 01000200 
                       PORT_PCR_SET_PTA2_UART0_TX
                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   59 00000000         ;---------------------------------------------------------------
   60 00000000         ;SIM_SCGC4
   61 00000000         ;1->10:UART0 clock gate control (enabled)
   62 00000000         ;Use provided SIM_SCGC4_UART0_MASK
   63 00000000         ;---------------------------------------------------------------
   64 00000000         ;SIM_SCGC5
   65 00000000         ;1->09:Port A clock gate control (enabled)
   66 00000000         ;Use provided SIM_SCGC5_PORTA_MASK
   67 00000000         ;---------------------------------------------------------------
   68 00000000         ;SIM_SOPT2
   69 00000000         ;01=27-26:UART0SRC=UART0 clock source select
   70 00000000         ;         (PLLFLLSEL determines MCGFLLCLK' or MCGPLLCLK/2)



ARM Macro Assembler    Page 3 Exercise 09 Serial I/O Driver


   71 00000000         ; 1=   16:PLLFLLSEL=PLL/FLL clock select (MCGPLLCLK/2)
   73 00000000 04000000 
                       SIM_SOPT2_UART0SRC_MCGPLLCLK
                               EQU              (1 << SIM_SOPT2_UART0SRC_SHIFT)
   75 00000000 04010000 
                       SIM_SOPT2_UART0_MCGPLLCLK_DIV2
                               EQU              (SIM_SOPT2_UART0SRC_MCGPLLCLK :OR: SIM_SOPT2_PLLFLLSEL_MASK)
   76 00000000         ;---------------------------------------------------------------
   77 00000000         ;SIM_SOPT5
   78 00000000         ; 0->   16:UART0 open drain enable (disabled)
   79 00000000         ; 0->   02:UART0 receive data select (UART0_RX)
   80 00000000         ;00->01-00:UART0 transmit data select source (UART0_TX)
   84 00000000 00010007 
                       SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
                               EQU              (SIM_SOPT5_UART0ODE_MASK :OR:                                  SIM_SOPT
5_UART0RXSRC_MASK :OR:                                  SIM_SOPT5_UART0TXSRC_MASK)
   85 00000000         ;---------------------------------------------------------------
   86 00000000         ;UART0_BDH
   87 00000000         ;    0->  7:LIN break detect IE (disabled)
   88 00000000         ;    0->  6:RxD input active edge IE (disabled)
   89 00000000         ;    0->  5:Stop bit number select (1)
   90 00000000         ;00001->4-0:SBR[12:0] (UART0CLK / [9600 * (OSR + 1)]) 
   91 00000000         ;UART0CLK is MCGPLLCLK/2
   92 00000000         ;MCGPLLCLK is 96 MHz
   93 00000000         ;MCGPLLCLK/2 is 48 MHz
   94 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   95 00000000 00000001 
                       UART0_BDH_9600
                               EQU              0x01
   96 00000000         ;---------------------------------------------------------------
   97 00000000         ;UART0_BDL
   98 00000000         ;26->7-0:SBR[7:0] (UART0CLK / [9600 * (OSR + 1)])
   99 00000000         ;UART0CLK is MCGPLLCLK/2
  100 00000000         ;MCGPLLCLK is 96 MHz
  101 00000000         ;MCGPLLCLK/2 is 48 MHz
  102 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
  103 00000000 00000038 
                       UART0_BDL_9600
                               EQU              0x38
  104 00000000         ;---------------------------------------------------------------
  105 00000000         ;UART0_C1
  106 00000000         ;0-->7:LOOPS=loops select (normal)



ARM Macro Assembler    Page 4 Exercise 09 Serial I/O Driver


  107 00000000         ;0-->6:DOZEEN=doze enable (disabled)
  108 00000000         ;0-->5:RSRC=receiver source select (internal--no effect LOOPS=0)
  109 00000000         ;0-->4:M=9- or 8-bit mode select 
  110 00000000         ;        (1 start, 8 data [lsb first], 1 stop)
  111 00000000         ;0-->3:WAKE=receiver wakeup method select (idle)
  112 00000000         ;0-->2:IDLE=idle line type select (idle begins after start bit)
  113 00000000         ;0-->1:PE=parity enable (disabled)
  114 00000000         ;0-->0:PT=parity type (even parity--no effect PE=0)
  115 00000000 00000000 
                       UART0_C1_8N1
                               EQU              0x00
  116 00000000         ;---------------------------------------------------------------
  117 00000000         ;UART0_C2
  118 00000000         ;0-->7:TIE=transmit IE for TDRE (disabled)
  119 00000000         ;0-->6:TCIE=transmission complete IE for TC (disabled)
  120 00000000         ;0-->5:RIE=receiver IE for RDRF (disabled)
  121 00000000         ;0-->4:ILIE=idle line IE for IDLE (disabled)
  122 00000000         ;1-->3:TE=transmitter enable (enabled)
  123 00000000         ;1-->2:RE=receiver enable (enabled)
  124 00000000         ;0-->1:RWU=receiver wakeup control (normal)
  125 00000000         ;0-->0:SBK=send break (disabled, normal)
  126 00000000 0000000C 
                       UART0_C2_T_R
                               EQU              (UART0_C2_TE_MASK :OR: UART0_C2_RE_MASK)
  127 00000000 0000002C 
                       UART0_C2_T_RI
                               EQU              (UART0_C2_RIE_MASK :OR: UART0_C2_T_R)
  128 00000000 000000AC 
                       UART0_C2_TI_RI
                               EQU              (UART0_C2_TIE_MASK :OR: UART0_C2_T_RI)
  129 00000000         ;---------------------------------------------------------------
  130 00000000         ;UART0_C3
  131 00000000         ;0-->7:R8T9=9th data bit for receiver (not used M=0)
  132 00000000         ;           10th data bit for transmitter (not used M10=0)
  133 00000000         ;0-->6:R9T8=9th data bit for transmitter (not used M=0)
  134 00000000         ;           10th data bit for receiver (not used M10=0)
  135 00000000         ;0-->5:TXDIR=UART_TX pin direction in single-wire mode
  136 00000000         ;            (no effect LOOPS=0)
  137 00000000         ;0-->4:TXINV=transmit data inversion (not inverted)
  138 00000000         ;0-->3:ORIE=overrun IE for OR (disabled)
  139 00000000         ;0-->2:NEIE=noise error IE for NF (disabled)
  140 00000000         ;0-->1:FEIE=framing error IE for FE (disabled)



ARM Macro Assembler    Page 5 Exercise 09 Serial I/O Driver


  141 00000000         ;0-->0:PEIE=parity error IE for PF (disabled)
  142 00000000 00000000 
                       UART0_C3_NO_TXINV
                               EQU              0x00
  143 00000000         ;---------------------------------------------------------------
  144 00000000         ;UART0_C4
  145 00000000         ;    0-->  7:MAEN1=match address mode enable 1 (disabled)
  146 00000000         ;    0-->  6:MAEN2=match address mode enable 2 (disabled)
  147 00000000         ;    0-->  5:M10=10-bit mode select (not selected)
  148 00000000         ;01111-->4-0:OSR=over sampling ratio (16)
  149 00000000         ;               = 1 + OSR for 3 <= OSR <= 31
  150 00000000         ;               = 16 for 0 <= OSR <= 2 (invalid values)
  151 00000000 0000000F 
                       UART0_C4_OSR_16
                               EQU              0x0F
  152 00000000 0000000F 
                       UART0_C4_NO_MATCH_OSR_16
                               EQU              UART0_C4_OSR_16
  153 00000000         ;---------------------------------------------------------------
  154 00000000         ;UART0_C5
  155 00000000         ;  0-->  7:TDMAE=transmitter DMA enable (disabled)
  156 00000000         ;  0-->  6:Reserved; read-only; always 0
  157 00000000         ;  0-->  5:RDMAE=receiver full DMA enable (disabled)
  158 00000000         ;000-->4-2:Reserved; read-only; always 0
  159 00000000         ;  0-->  1:BOTHEDGE=both edge sampling (rising edge only)
  160 00000000         ;  0-->  0:RESYNCDIS=resynchronization disable (enabled)
  161 00000000 00000000 
                       UART0_C5_NO_DMA_SSR_SYNC
                               EQU              0x00
  162 00000000         ;---------------------------------------------------------------
  163 00000000         ;UART0_S1
  164 00000000         ;0-->7:TDRE=transmit data register empty flag; read-only
  165 00000000         ;0-->6:TC=transmission complete flag; read-only
  166 00000000         ;0-->5:RDRF=receive data register full flag; read-only
  167 00000000         ;1-->4:IDLE=idle line flag; write 1 to clear (clear)
  168 00000000         ;1-->3:OR=receiver overrun flag; write 1 to clear (clear)
  169 00000000         ;1-->2:NF=noise flag; write 1 to clear (clear)
  170 00000000         ;1-->1:FE=framing error flag; write 1 to clear (clear)
  171 00000000         ;1-->0:PF=parity error flag; write 1 to clear (clear)
  172 00000000 0000001F 
                       UART0_S1_CLEAR_FLAGS
                               EQU              0x1F



ARM Macro Assembler    Page 6 Exercise 09 Serial I/O Driver


  173 00000000         ;---------------------------------------------------------------
  174 00000000         ;UART0_S2
  175 00000000         ;1-->7:LBKDIF=LIN break detect interrupt flag (clear)
  176 00000000         ;             write 1 to clear
  177 00000000         ;1-->6:RXEDGIF=RxD pin active edge interrupt flag (clear)
  178 00000000         ;              write 1 to clear
  179 00000000         ;0-->5:(reserved); read-only; always 0
  180 00000000         ;0-->4:RXINV=receive data inversion (disabled)
  181 00000000         ;0-->3:RWUID=receive wake-up idle detect
  182 00000000         ;0-->2:BRK13=break character generation length (10)
  183 00000000         ;0-->1:LBKDE=LIN break detect enable (disabled)
  184 00000000         ;0-->0:RAF=receiver active flag; read-only
  185 00000000 000000C0 
                       UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
                               EQU              0xC0
  186 00000000         ;---------------------------------------------------------------
  187 00000000         ;Max length of queue
  188 00000000 00000004 
                       Q_BUF_SZ
                               EQU              4
  189 00000000 00000012 
                       Q_REC_SZ
                               EQU              18
  190 00000000         ;Max length of prompt string
  191 00000000 0000004F 
                       MAX_STRING
                               EQU              79
  192 00000000 00000000 
                       IN_PTR  EQU              0
  193 00000000 00000004 
                       OUT_PTR EQU              4
  194 00000000 00000008 
                       BUF_START
                               EQU              8
  195 00000000 0000000C 
                       BUF_PAST
                               EQU              12
  196 00000000 00000010 
                       BUF_SIZE
                               EQU              16
  197 00000000 00000011 
                       NUM_ENQD



ARM Macro Assembler    Page 7 Exercise 09 Serial I/O Driver


                               EQU              17
  198 00000000         
  199 00000000         ;****************************************************************
  200 00000000         ;Program
  201 00000000         ;Linker requires Reset_Handler
  202 00000000                 AREA             MyCode,CODE,READONLY
  203 00000000                 ENTRY
  204 00000000                 EXPORT           Reset_Handler
  205 00000000                 IMPORT           Startup
  206 00000000         Reset_Handler
  207 00000000         main
  208 00000000 B672            CPSID            I
  209 00000002         ;---------------------------------------------------------------
  210 00000002         ;KL46 system startup with 48-MHz system clock
  211 00000002 F7FF FFFE       BL               Startup
  212 00000006 F000 F9C6       BL               Init_UART0_IRQ
  213 0000000A         ;>>>>> begin main program code <<<<<
  214 0000000A 480D            LDR              R0,=Queue   ;Initialize starting point of queue
  215 0000000C 490D            LDR              R1,=QueueRecord ;Initialize queue record
  216 0000000E 2204            MOVS             R2,#4       ;Initialize queue length, this will not change
  217 00000010 F000 F8FA       BL               InitQueue   ;Initalize queu record structure
  218 00000014         MAIN
  219 00000014 480C            LDR              R0,=MainString ;MainString in R0 
  220 00000016 F000 F981       BL               PutStringSB ;Print MainString
  221 0000001A         INPUTLOOP                            ;Loop for reading input
  222 0000001A F000 F95E       BL               GETCHAR     ;read input char put in R0
  223 0000001E 0004            MOVS             R4,R0       ;Char goes to R4 for copy
  224 00000020 285E            CMP              R0,#94      ;If Char is lowercase
  225 00000022 DC00            BGT              Skip
  226 00000024 3020            ADDS             R0,R0,#32   ;Add decimal 32, turns it to lowercase
  227 00000026         Skip
  228 00000026 2864            CMP              R0,#100     ;If d
  229 00000028 D010            BEQ              DOSTUFFd    ;
  230 0000002A 2865            CMP              R0,#101     ;If e
  231 0000002C D02C            BEQ              DOSTUFFe
  232 0000002E 2868            CMP              R0,#104     ;If h
  233 00000030 D04F            BEQ              DOSTUFFh
  234 00000032 2870            CMP              R0,#112     ;If p
  235 00000034 D065            BEQ              DOSTUFFp
  236 00000036 2873            CMP              R0,#115     ;If s
  237 00000038 D056            BEQ              DOSTUFFs
  238 0000003A E7EE            B                INPUTLOOP



ARM Macro Assembler    Page 8 Exercise 09 Serial I/O Driver


  239 0000003C E7FE            B                .
  240 0000003E 00 00 00000000 
              00000000 
              00000000         LTORG
  241 0000004C         ;>>>>>   end main program code <<<<<
  242 0000004C         ;-------------------------------------------
  243 0000004C         ;>>>>> begin subroutine code <<<<<
  244 0000004C         ;This subroutine preforms deques when d is entered in the terminal
  245 0000004C         ;Input parameters:
  246 0000004C         ;   R0, lower d
  247 0000004C         ;Output parameters:
  248 0000004C         ;   None
  249 0000004C         ;Modified Registers
  250 0000004C         ;   
  251 0000004C         DOSTUFFd
  252 0000004C 0020            MOVS             R0,R4
  253 0000004E F000 F939       BL               PUTCHAR     ;Echo character
  254 00000052 F000 FA03       BL               NEXTLINE
  255 00000056         
  256 00000056 F000 F8E0       BL               Dequeue     ;Attempt to dequeue character
  257 0000005A         DidDequeueWork
  258 0000005A D300            BCC              DequeueWorked
  259 0000005C D207            BCS              DequeueDidNotWork
  260 0000005E         DequeueWorked
  261 0000005E 7800            LDRB             R0,[R0,#0]  ;get char to print
  262 00000060 F000 F930       BL               PUTCHAR     ;Print dequeued character
  263 00000064 203A            MOVS             R0,#":"     ;SemiColon
  264 00000066 F000 F92D       BL               PUTCHAR     ;Print SemiColon
  265 0000006A F000 F805       BL               ContinueDOSTUFFd
  266 0000006E         DequeueDidNotWork
  267 0000006E 48FF            LDR              R0,=FailureString
  268 00000070 F000 F954       BL               PutStringSB
  269 00000074 F000 F800       BL               ContinueDOSTUFFd
  270 00000078         ContinueDOSTUFFd
  271 00000078 48FD            LDR              R0,=TabString ;need tab between success/failure and status
  272 0000007A F000 F94F       BL               PutStringSB
  273 0000007E F000 F863       BL               PrintStatus
  274 00000082 F000 F9EB       BL               NEXTLINE    ;NextLine
  275 00000086 E7C5            B                MAIN        ;Back to begining of main
  276 00000088         
  277 00000088         
  278 00000088         ;This subroutine enques a character when e is entered 



ARM Macro Assembler    Page 9 Exercise 09 Serial I/O Driver


  279 00000088         ;Input parameters:
  280 00000088         ;   R0=e
  281 00000088         ;Output parameters:
  282 00000088         ;   None
  283 00000088         ;Modified Registers
  284 00000088         ;   
  285 00000088         DOSTUFFe
  286 00000088 0020            MOVS             R0,R4
  287 0000008A F000 F91B       BL               PUTCHAR     ;Echo
  288 0000008E F000 F9E5       BL               NEXTLINE
  289 00000092 48F8            LDR              R0,=eString
  290 00000094 F000 F942       BL               PutStringSB ;Print string 
  291 00000098 F000 F91F       BL               GETCHAR
  292 0000009C F000 F912       BL               PUTCHAR     ;echo chartacter
  293 000000A0 49F5            LDR              R1,=QueueRecord ;Initialize queue record
  294 000000A2 F000 F8E5       BL               Enqueue
  295 000000A6 F000 F9D9       BL               NEXTLINE
  296 000000AA D300            BCC              EnqueueWorked
  297 000000AC D204            BCS              EnqueueDidNotWork
  298 000000AE         EnqueueWorked
  299 000000AE 48F3            LDR              R0,=SuccessString
  300 000000B0 F000 F934       BL               PutStringSB
  301 000000B4 F000 F805       BL               ContinueDOSTUFFe
  302 000000B8         EnqueueDidNotWork
  303 000000B8 48EC            LDR              R0,=FailureString
  304 000000BA F000 F92F       BL               PutStringSB
  305 000000BE F000 F800       BL               ContinueDOSTUFFe
  306 000000C2         ContinueDOSTUFFe
  307 000000C2 48EB            LDR              R0,=TabString ;need tab between success/failure and status
  308 000000C4 F000 F92A       BL               PutStringSB
  309 000000C8 F000 F83E       BL               PrintStatus
  310 000000CC F000 F9C6       BL               NEXTLINE    ;NextLine
  311 000000D0 E7A0            B                MAIN        ;Back to begining of main
  312 000000D2         
  313 000000D2         ;This subroutine displays the help menu when e is entered in the terminal
  314 000000D2         ;Input parameters:
  315 000000D2         ;   R0 = h
  316 000000D2         ;Output parameters:
  317 000000D2         ;   None
  318 000000D2         ;Modified Registers
  319 000000D2         ;   
  320 000000D2         DOSTUFFh



ARM Macro Assembler    Page 10 Exercise 09 Serial I/O Driver


  321 000000D2 0020            MOVS             R0,R4
  322 000000D4 F000 F8F6       BL               PUTCHAR     ;Echo
  323 000000D8 F000 F9C0       BL               NEXTLINE
  324 000000DC 48E8            LDR              R0,=HelpString ;help string to print
  325 000000DE F000 F91D       BL               PutStringSB
  326 000000E2 F000 F9BB       BL               NEXTLINE
  327 000000E6 E795            B                MAIN
  328 000000E8         
  329 000000E8         ;This subroutine displays the status of the queue when s is entered in the terminal
  330 000000E8         ;Input parameters:
  331 000000E8         ;   R0 = s
  332 000000E8         ;Output parameters:
  333 000000E8         ;   None
  334 000000E8         ;Modified Registers
  335 000000E8         ;   
  336 000000E8         DOSTUFFs
  337 000000E8 0020            MOVS             R0,R4
  338 000000EA F000 F8EB       BL               PUTCHAR     ;Echo
  339 000000EE F000 F9B5       BL               NEXTLINE
  340 000000F2 48E4            LDR              R0,=StatusString ;"status:"
  341 000000F4 F000 F912       BL               PutStringSB
  342 000000F8 F000 F826       BL               PrintStatus
  343 000000FC F000 F9AE       BL               NEXTLINE
  344 00000100 E788            B                MAIN
  345 00000102         ;This subroutine prints the queue when p is entered in the terminal
  346 00000102         ;Input parameters:
  347 00000102         ;   R0 = p
  348 00000102         ;Output parameters:
  349 00000102         ;   None
  350 00000102         ;Modified Registers
  351 00000102         ;   
  352 00000102         DOSTUFFp
  353 00000102 0020            MOVS             R0,R4
  354 00000104 F000 F8DE       BL               PUTCHAR     ;Print Character to Console
  355 00000108 F000 F9A8       BL               NEXTLINE    ;NextLine
  356 0000010C 203E            MOVS             R0,#">"     ;">" 
  357 0000010E F000 F8D9       BL               PUTCHAR     ;Print ">"
  358 00000112 49D9            LDR              R1,=QueueRecord ;Initialize queue record
  359 00000114 7C4A            LDRB             R2,[R1,#NUM_ENQD] ;get number enqueued
  360 00000116 2500            MOVS             R5,#0
  361 00000118 42AA            CMP              R2,R5       ;Compare num enqued and 0
  362 0000011A D30F            BLO              EndPrint    ;Branch if num enqd =< 0



ARM Macro Assembler    Page 11 Exercise 09 Serial I/O Driver


  363 0000011C 684B            LDR              R3,[R1,#OUT_PTR] ;get adress of outpointer
  364 0000011E 680C            LDR              R4,[R1,#IN_PTR] ;Load R4 with inpt
  365 00000120         LoopieCond
  366 00000120         
  367 00000120 42AA            CMP              R2,R5       ;Compare Num enqd and 0
  368 00000122 D00B            BEQ              EndPrint    ;If equal you have reached the end
  369 00000124         
  370 00000124         Loopie
  371 00000124 781C            LDRB             R4,[R3,#0]  ;Store character in R4
  372 00000126 0020            MOVS             R0,R4
  373 00000128 F000 F8CC       BL               PUTCHAR     ;Print character
  374 0000012C 1C5B            ADDS             R3,R3,#1    ;Increment outpointer*
  375 0000012E 1E52            SUBS             R2,R2,#1    ;Sub NumEnqd*
  376 00000130 68CE            LDR              R6,[R1,#BUF_PAST] ;get buffer past
  377 00000132 42B3            CMP              R3,R6       ;Compare Outpointer* to BufferPast
  378 00000134 DC00            BGT              NeedToWrapToBegining
  379 00000136 E7F3            B                LoopieCond
  380 00000138         NeedToWrapToBegining
  381 00000138 688B            LDR              R3,[R1,#BUF_START] ;Move outpointer* to buff start
  382 0000013A E7F1            B                LoopieCond  ;Loop
  383 0000013C         
  384 0000013C         EndPrint
  385 0000013C 203C            MOVS             R0,#"<"     ;"<" 
  386 0000013E F000 F8C1       BL               PUTCHAR     ;Print "<"
  387 00000142 F000 F98B       BL               NEXTLINE    ;NextLine
  388 00000146 E765            B                MAIN        ;Back to begining of main
  389 00000148         ;This subroutine displays the status of the queue when called
  390 00000148         ;Input parameters:
  391 00000148         ;   None
  392 00000148         ;Output parameters:
  393 00000148         ;   None
  394 00000148         ;Modified Registers
  395 00000148         ;   None
  396 00000148         PrintStatus
  397 00000148 B5FF            PUSH             {R0-R7,LR}
  398 0000014A 48CF            LDR              R0,=InString ;"In="
  399 0000014C F000 F8E6       BL               PutStringSB
  400 00000150 49C9            LDR              R1,=QueueRecord ;Initialize queue record
  401 00000152 6808            LDR              R0,[R1,#IN_PTR] ;get inpointer value
  402 00000154 F000 F842       BL               PutNumHex
  403 00000158 48CC            LDR              R0,=TabString2 ;"  "
  404 0000015A F000 F8DF       BL               PutStringSB



ARM Macro Assembler    Page 12 Exercise 09 Serial I/O Driver


  405 0000015E 48CC            LDR              R0,=OutString ;"Out="
  406 00000160 F000 F8DC       BL               PutStringSB
  407 00000164 6848            LDR              R0,[R1,#OUT_PTR] ;get outpointer value
  408 00000166 F000 F839       BL               PutNumHex
  409 0000016A 48C8            LDR              R0,=TabString2 ;"  "
  410 0000016C F000 F8D6       BL               PutStringSB
  411 00000170 48C8            LDR              R0,=NumString ;"Num="
  412 00000172 F000 F8D3       BL               PutStringSB
  413 00000176 7C48            LDRB             R0,[R1,#NUM_ENQD] ;get num enqd value
  414 00000178 3030            ADDS             R0,R0,#48   ;get ascii equivalent
  415 0000017A F000 F8A3       BL               PUTCHAR
  416 0000017E BDFF            POP              {R0-R7,PC}
  417 00000180 4770            BX               LR
  418 00000182         
  419 00000182         ;PutNumUB: Print the least significant unsigned 
  420 00000182         ;byte value from R0 to the screen. 
  421 00000182         
  422 00000182         ;Inputs:
  423 00000182         ;R0 = value to print to the terminal screen in UB form
  424 00000182         ;Outputs
  425 00000182         ;N/A
  426 00000182         PutNumUB
  427 00000182 B502            PUSH             {R1, LR}
  428 00000184 21FF            MOVS             R1, #0xFF
  429 00000186         ;Mask off everything but the last byte
  430 00000186 4008            ANDS             R0, R0, R1
  431 00000188 F000 F952       BL               PutNumU
  432 0000018C BD02            POP              {R1, PC}
  433 0000018E         
  434 0000018E         ;UART0_ISR
  435 0000018E         ;Interrupt service routine for UART0 
  436 0000018E         ;Check status of interrupt that triggered the ISR
  437 0000018E         ;And react appropriately. If transmit interrupt enabled,
  438 0000018E         ;write to UART0 transmit data register. If rx enabled
  439 0000018E         ;enqueue to transmit queue from UART0 recieve data register
  440 0000018E         
  441 0000018E         UART0_ISR
  442 0000018E         
  443 0000018E         ;Mask other interrupts
  444 0000018E B672            CPSID            I
  445 00000190         ;Pust relevant registers on to the stack
  446 00000190 B50F            PUSH             {LR, R0-R3}



ARM Macro Assembler    Page 13 Exercise 09 Serial I/O Driver


  447 00000192 48C6            LDR              R0, =UART0_BASE
  448 00000194         ;If txinterrupt enabled (UART0_C2 Bit 7 is set)
  449 00000194 78C1            LDRB             R1,[R0,#UART0_C2_OFFSET]
  450 00000196 2280            MOVS             R2, #0x80
  451 00000198 4011            ANDS             R1, R1, R2
  452 0000019A 2900            CMP              R1, #0
  453 0000019C D100            BNE              TX_ENABLED
  454 0000019E         ;If no TxInterrupt, check for Rx
  455 0000019E E00F            B                CHECK_RX_INT
  456 000001A0         
  457 000001A0         TX_ENABLED
  458 000001A0 7901            LDRB             R1,[R0,#UART0_S1_OFFSET]
  459 000001A2 2280            MOVS             R2, #0x80
  460 000001A4 4011            ANDS             R1, R1, R2
  461 000001A6 2900            CMP              R1, #0
  462 000001A8 D00A            BEQ              CHECK_RX_INT
  463 000001AA         ;Dequeue character
  464 000001AA         ;Load input params to initalize queue structure
  465 000001AA 49BB            LDR              R1, =TxQueueRecord
  466 000001AC 2204            MOVS             R2, #Q_BUF_SZ
  467 000001AE F000 F834       BL               Dequeue
  468 000001B2         ;Dequeue was unsuccessful
  469 000001B2 D202            BCS              DISABLE_TX
  470 000001B4         ;Dequeue was successful
  471 000001B4 49BD            LDR              R1, =UART0_BASE
  472 000001B6         ;Transmit Character Stored in R0
  473 000001B6 71C8            STRB             R0, [R1, #UART0_D_OFFSET]
  474 000001B8 E00E            B                END_ISR
  475 000001BA         
  476 000001BA         DISABLE_TX
  477 000001BA         ;UART0 <- C2_T_RI
  478 000001BA 212C            MOVS             R1,#UART0_C2_T_RI
  479 000001BC 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  480 000001BE         ;Pop values and return
  481 000001BE E00B            B                END_ISR
  482 000001C0         CHECK_RX_INT
  483 000001C0 48BA            LDR              R0, =UART0_BASE
  484 000001C2         ;Check if an RxInterrupt exists
  485 000001C2 7901            LDRB             R1,[R0,#UART0_S1_OFFSET]
  486 000001C4 2210            MOVS             R2, #0x10
  487 000001C6 4011            ANDS             R1, R1, R2
  488 000001C8 2900            CMP              R1, #0



ARM Macro Assembler    Page 14 Exercise 09 Serial I/O Driver


  489 000001CA D005            BEQ              END_ISR
  490 000001CC         ;Receive character and store in R0
  491 000001CC 48B7            LDR              R0, =UART0_BASE
  492 000001CE 79C3            LDRB             R3, [R0, #UART0_D_OFFSET]
  493 000001D0         ;Enqueue character with character stored in R0
  494 000001D0         ;Load input params to initalize queue structure
  495 000001D0 49B2            LDR              R1, =RxQueueRecord
  496 000001D2 0018            MOVS             R0, R3
  497 000001D4 F000 F84C       BL               Enqueue
  498 000001D8         ;No need to check return of EnQueue
  499 000001D8         ;character will be lost if the queue is full!
  500 000001D8         
  501 000001D8         END_ISR
  502 000001D8         ;pop relevant registers off the stack
  503 000001D8         ;Unmask other interrupts
  504 000001D8 B662            CPSIE            I
  505 000001DA         ;Return back to our business
  506 000001DA BD0F            POP              {R0-R3, PC}
  507 000001DC         
  508 000001DC         
  509 000001DC         ;PutNumHex: Print hex representation of a value
  510 000001DC         ;To the console. Separates each nibble via masking
  511 000001DC         ;And then converts to appropriate ASCII representation
  512 000001DC         ;Inputs:
  513 000001DC         ;R0 - Value to print to the screen
  514 000001DC         ;Outputs: N/A
  515 000001DC         PutNumHex
  516 000001DC B51C            PUSH             {R2, R3, R4, LR}
  517 000001DE 2220            MOVS             R2, #32
  518 000001E0         HEX_PRINT_LOOP
  519 000001E0         ;Iterate 8 times for each digit stored in a register
  520 000001E0 2A00            CMP              R2, #0
  521 000001E2 DB10            BLT              END_PRINT_HEX
  522 000001E4         ;Shift current nibble to print to
  523 000001E4         ;the rightmost value of register
  524 000001E4 0003            MOVS             R3, R0
  525 000001E6 240F            MOVS             R4, #0x0F
  526 000001E8 40D3            LSRS             R3, R2
  527 000001EA 401C            ANDS             R4, R4, R3
  528 000001EC         ;Convert to appropriate ASCII value
  529 000001EC 2C0A            CMP              R4, #10
  530 000001EE DA01            BGE              PRINT_LETTER



ARM Macro Assembler    Page 15 Exercise 09 Serial I/O Driver


  531 000001F0         ;If 0-9 should be printed, add ASCII '0' val
  532 000001F0 3430            ADDS             R4, #'0'
  533 000001F2 E000            B                PRINT_HX
  534 000001F4         PRINT_LETTER
  535 000001F4         ;If A-F should be printed, Add ASCII '55'
  536 000001F4         ;To convert to capital letter value
  537 000001F4 3437            ADDS             R4, R4, #55
  538 000001F6         PRINT_HX
  539 000001F6         ;Print ASCII value to the screen
  540 000001F6         ;Make sure not to destroy vlue in R0!
  541 000001F6 B401            PUSH             {R0}
  542 000001F8 0020            MOVS             R0, R4
  543 000001FA F000 F863       BL               PUTCHAR
  544 000001FE BC01            POP              {R0}
  545 00000200         ;Reset value in R3 and increment loop counter
  546 00000200 2400            MOVS             R4, #0
  547 00000202 1F12            SUBS             R2, R2, #4
  548 00000204 E7EC            B                HEX_PRINT_LOOP
  549 00000206         
  550 00000206         END_PRINT_HEX
  551 00000206         
  552 00000206 BD1C            POP              {R2, R3, R4, PC}
  553 00000208         
  554 00000208         ;This subroutine initializes an empty queue
  555 00000208         ;Input parameters:
  556 00000208         ;   R0, queue buffer address 
  557 00000208         ;   R1, queue record structure
  558 00000208         ; R2, queue size
  559 00000208         ;Output parameters:
  560 00000208         ;   None 
  561 00000208         ;Modified Registers
  562 00000208         ; None 
  563 00000208         
  564 00000208         InitQueue
  565 00000208 6008            STR              R0,[R1,#IN_PTR] ;Initialize In pointer to start of queue
  566 0000020A 6048            STR              R0,[R1,#OUT_PTR] ;Initialize Out pointer to start of queue
  567 0000020C 6088            STR              R0,[R1,#BUF_START] ;Initialize buffer start to start of queue
  568 0000020E 1880            ADDS             R0,R0,R2    ;End of queue
  569 00000210 60C8            STR              R0,[R1,#BUF_PAST] ;Initialize buffer past
  570 00000212 610A            STR              R2,[R1,#BUF_SIZE] ;Initialize buffer size to 4
  571 00000214 2000            MOVS             R0,#0
  572 00000216 7448            STRB             R0,[R1,#NUM_ENQD] ;Initialize num enqd to 0



ARM Macro Assembler    Page 16 Exercise 09 Serial I/O Driver


  573 00000218 4770            BX               LR
  574 0000021A         ;This subroutine dequeues a character
  575 0000021A         ;Input paramters:
  576 0000021A         ; R1: Address of queue record structure
  577 0000021A         ;Output:
  578 0000021A         ; PSR C flag: success(0) or failure (1)
  579 0000021A         ; r0: Character to dequeued 
  580 0000021A         ;Modify: PSR
  581 0000021A         Dequeue
  582 0000021A B4FF            PUSH             {R0-R7}
  583 0000021C 7C4A            LDRB             R2,[R1,#NUM_ENQD] ;get number enqueued
  584 0000021E 2300            MOVS             R3,#0
  585 00000220 429A            CMP              R2,R3       ;Compare num enqued and 0
  586 00000222 D91A            BLS              QueueEmpty  ;Branch if num enqd =< 0
  587 00000224 684C            LDR              R4,[R1,#OUT_PTR] ;get adress of outpointer
  588 00000226 1C64            ADDS             R4,R4,#1    ;Increment out pointer
  589 00000228 604C            STR              R4,[R1,#OUT_PTR] ;Store new adredd of outpointer
  590 0000022A 1E52            SUBS             R2,R2,#1    ;decrement number enqued
  591 0000022C 744A            STRB             R2,[R1,#NUM_ENQD] ;store number enqued
  592 0000022E 68CA            LDR              R2,[R1,#BUF_PAST] ;get buffer past
  593 00000230 1E67            SUBS             R7,R4,#1    ;get address of dequeued character
  594 00000232 4294            CMP              R4,R2       ;Compare Outpointer to BufferStart
  595 00000234 DA07            BGE              NeedToWrapAgain
  596 00000236 F3EF 8000       MRS              R0,APSR     ;Clear carry to show success (Lec notes M,2/8 slide #5) 
  597 0000023A 2120            MOVS             R1,#0x20
  598 0000023C 0609            LSLS             R1,R1,#24
  599 0000023E 4388            BICS             R0,R0,R1
  600 00000240 F380 8800       MSR              APSR,R0
  601 00000244 E011            B                EndDequeue  ;End
  602 00000246         NeedToWrapAgain
  603 00000246 4896            LDR              R0,=Queue   ;Initialize starting point of queue
  604 00000248 6048            STR              R0,[R1,#OUT_PTR] ;Move outpointer to buff start
  605 0000024A F3EF 8000       MRS              R0,APSR     ;Clear carry to show success (Lec notes M,2/8 slide #5) 
  606 0000024E 2120            MOVS             R1,#0x20
  607 00000250 0609            LSLS             R1,R1,#24
  608 00000252 4388            BICS             R0,R0,R1
  609 00000254 F380 8800       MSR              APSR,R0
  610 00000258 E007            B                EndDequeue  ;End
  611 0000025A         QueueEmpty
  612 0000025A F3EF 8000       MRS              R0,APSR     ;Show unsuccesfull enque by setting carry flag
  613 0000025E 2120            MOVS             R1,#0x20
  614 00000260 0609            LSLS             R1,R1,#24



ARM Macro Assembler    Page 17 Exercise 09 Serial I/O Driver


  615 00000262 4308            ORRS             R0,R0,R1
  616 00000264 F380 8800       MSR              APSR, R0
  617 00000268 E7FF            B                EndDequeue  ;End
  618 0000026A         EndDequeue
  619 0000026A         
  620 0000026A 0038            MOVS             R0,R7       ;Move address of deued dequeued character to R0
  621 0000026C BCFE            POP              {R1-R7}
  622 0000026E 4770            BX               LR
  623 00000270         
  624 00000270         ;This subroutine enqueues a character
  625 00000270         ;Input paramters:
  626 00000270         ; r0: Character to enque 
  627 00000270         ; R1: Address of queue record structure
  628 00000270         ;Output:
  629 00000270         ; PSR C flag: success(0) or failure (1)
  630 00000270         ;Modify: PSR
  631 00000270         Enqueue
  632 00000270 B41F            PUSH             {R0-R4}
  633 00000272         
  634 00000272 7C4A            LDRB             R2,[R1,#NUM_ENQD] ;get number enqued
  635 00000274 7C0B            LDRB             R3,[R1,#BUF_SIZE]
  636 00000276 429A            CMP              R2,R3       ;Compare num enqd to buff size
  637 00000278 DA10            BGE              Queuefull   ;Branch if num enqd >= buff size
  638 0000027A 680C            LDR              R4,[R1,#IN_PTR] ;get inpointer address
  639 0000027C 7020            STRB             R0,[R4,#0]  ;Store character at In pointer
  640 0000027E 1C64            ADDS             R4,R4,#1    ;Increment inpointer address
  641 00000280 700C            STRB             R4,[R1,#IN_PTR] ;Store incremented inpointer value
  642 00000282 1C52            ADDS             R2,R2,#1    ;Increment Numenqd
  643 00000284 744A            STRB             R2,[R1,#NUM_ENQD] ;Store incremented enqd value
  644 00000286 68CA            LDR              R2,[R1,#BUF_PAST] ;get buff past value
  645 00000288 4294            CMP              R4,R2       ;Compare inpointer to outpionter
  646 0000028A D00F            BEQ              NeedToWrap  ;If Inptr < Buff past
  647 0000028C F3EF 8000       MRS              R0,APSR     ;Clear carry to show success (Lec notes M,2/8 slide #5) 
  648 00000290 2120            MOVS             R1,#0x20
  649 00000292 0609            LSLS             R1,R1,#24
  650 00000294 4388            BICS             R0,R0,R1
  651 00000296 F380 8800       MSR              APSR,R0
  652 0000029A E011            B                EndEnqueue  ;End 
  653 0000029C         Queuefull
  654 0000029C F3EF 8000       MRS              R0,APSR     ;Show unsuccesfull enque by setting carry flag
  655 000002A0 2120            MOVS             R1,#0x20
  656 000002A2 0609            LSLS             R1,R1,#24



ARM Macro Assembler    Page 18 Exercise 09 Serial I/O Driver


  657 000002A4 4308            ORRS             R0,R0,R1
  658 000002A6 F380 8800       MSR              APSR, R0
  659 000002AA E009            B                EndEnqueue  ;End
  660 000002AC         NeedToWrap
  661 000002AC         
  662 000002AC 688A            LDR              R2,[R1,#BUF_START] ;get buffer start
  663 000002AE 600A            STR              R2,[R1,#IN_PTR] ;adjust inpointer to start of queue
  664 000002B0 F3EF 8000       MRS              R0,APSR     ;Clear carry to show success (Lec notes M,2/8 slide #5) 
  665 000002B4 2120            MOVS             R1,#0x20
  666 000002B6 0609            LSLS             R1,R1,#24
  667 000002B8 4388            BICS             R0,R0,R1
  668 000002BA F380 8800       MSR              APSR,R0
  669 000002BE E7FF            B                EndEnqueue  ;End
  670 000002C0         EndEnqueue
  671 000002C0 BC1F            POP              {R0-R4}
  672 000002C2 4770            BX               LR
  673 000002C4         
  674 000002C4         
  675 000002C4         ;Send a character out of UART0 using interrupts
  676 000002C4         ;Inputs
  677 000002C4         ; R0 - Character to enqueue to TxQueue
  678 000002C4         ;Return - N/A
  679 000002C4         PUTCHAR
  680 000002C4 B503            PUSH             {R0, R1,LR}
  681 000002C6         REPEAT_ENQ
  682 000002C6         ;initalize queue structure
  683 000002C6 4974            LDR              R1, =TxQueueRecord
  684 000002C8         ;Mask  interrupts
  685 000002C8 B672            CPSID            I
  686 000002CA         ;Enqueue character in R0, Enqueue uses R0
  687 000002CA F7FF FFD1       BL               Enqueue
  688 000002CE         ;Enable interrupts
  689 000002CE B662            CPSIE            I
  690 000002D0 D2F9            BCS              REPEAT_ENQ
  691 000002D2         ;Enable UART0 Transmitter, reciever, and rx interrupt
  692 000002D2 4876            LDR              R0, =UART0_BASE
  693 000002D4 21AC            MOVS             R1,#UART0_C2_TI_RI
  694 000002D6 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  695 000002D8 BD03            POP              {R0, R1, PC}
  696 000002DA         ;Return
  697 000002DA         
  698 000002DA         ;Receive a character from UART0 using interrupts



ARM Macro Assembler    Page 19 Exercise 09 Serial I/O Driver


  699 000002DA         ;Inputs - N/A
  700 000002DA         ;Return
  701 000002DA         ; R0 - Character dequeued from RxQueue
  702 000002DA         GETCHAR
  703 000002DA B506            PUSH             {R1, R2, LR}
  704 000002DC 496F            LDR              R1, =RxQueueRecord
  705 000002DE         REPEAT_DEQ
  706 000002DE         ;Mask all interrupts
  707 000002DE B672            CPSID            I
  708 000002E0         ;dequeue whats in R0 
  709 000002E0 F7FF FF9B       BL               Dequeue
  710 000002E4         ;Enable interrupts
  711 000002E4 B662            CPSIE            I
  712 000002E6         ;Loop
  713 000002E6 D2FA            BCS              REPEAT_DEQ
  714 000002E8 BD06            POP              {R1, R2, PC}
  715 000002EA         
  716 000002EA         
  717 000002EA         ;The follwing subroutine reads a string of chars from the keyboard
  718 000002EA         ;and stores them in a string dtarting from R0. For each character 
  719 000002EA         ;up to R1-1 it echoes the character and when the carage character (13-10 0D-16)
  720 000002EA         ;is not recieved it null terminates the string. it then moves
  721 000002EA         ;the cursor to the begining of the next line
  722 000002EA         ;Input parameters:
  723 000002EA         ;   R1 one more than the oveflow buffer
  724 000002EA         ; R0 pointer to address of string 
  725 000002EA         ;Output parameters:
  726 000002EA         ;   None
  727 000002EA         ;Modified Registers
  728 000002EA         ;   None. The original contents of the registers are restored 
  729 000002EA         ;                 
  730 000002EA         GetStringSB
  731 000002EA B40F            PUSH             {R0-R3}     ;Push registers as to not overwrite original values
  732 000002EC 1E49            SUBS             R1,R1,#1    ;Amount of elements we can check
  733 000002EE 0003            MOVS             R3,R0       ;Move address into R3
  734 000002F0 2200            MOVS             R2,#0
  735 000002F2         LoopCond
  736 000002F2 F7FF FFF2       BL               GETCHAR     ;GETCHAR, store Char in R0
  737 000002F6 280D            CMP              R0,#0x0D    ;Make Sure Carraige return has not been selected
  738 000002F8 D006            BEQ              ENDLOOP     ;End if Carraige Return has been recieved
  739 000002FA 428A            CMP              R2,R1       ;Make sure the Max_String value hasnt been reached
  740 000002FC D0F9            BEQ              LoopCond    ;End if the Max_String value has been reached



ARM Macro Assembler    Page 20 Exercise 09 Serial I/O Driver


  741 000002FE F7FF FFE1       BL               PUTCHAR     ;Return  to console
  742 00000302 5498            STRB             R0,[R3,R2]  ;Store char in array  
  743 00000304 1C52            ADDS             R2,R2,#1    ;R2 increment
  744 00000306 E7F4            B                LoopCond
  745 00000308         ENDLOOP
  746 00000308 2000            MOVS             R0,#00      ;Null terminate
  747 0000030A 5498            STRB             R0,[R3,R2]  ;Store Null terminate 
  748 0000030C 200D            MOVS             R0, #0x0D
  749 0000030E F7FF FFD9       BL               PUTCHAR
  750 00000312 200A            MOVS             R0, #0x0A
  751 00000314 F7FF FFD6       BL               PUTCHAR
  752 00000318 BC0F            POP              {R0-R3}     ;Pop registers back off 
  753 0000031A E67B            B                MAIN
  754 0000031C         
  755 0000031C         
  756 0000031C         ;Displays a null terminated string to the terminal screen from memory starting at R0 
  757 0000031C         ;Preventing overun of the buffer capacity specified by R1
  758 0000031C         ;Leaves cursor specified in R1
  759 0000031C         
  760 0000031C         PutStringSB
  761 0000031C B51E            PUSH             {R1,R2,R3,R4,LR} ;Push registers as to not overwrite original values
  762 0000031E F000 F80D       BL               LengthStringSB
  763 00000322 0011            MOVS             R1, R2
  764 00000324         READ_CHAR
  765 00000324         ;If all characters have been displayed then end
  766 00000324 2900            CMP              R1, #0
  767 00000326 D008            BEQ              END_PUT_STR
  768 00000328         ;Get the next character of input and store in R3
  769 00000328 7803            LDRB             R3, [R0, #0]
  770 0000032A         ;Display character to the terminal
  771 0000032A B401            PUSH             {R0}        ;Preserve state of R0 and LR
  772 0000032C 0018            MOVS             R0, R3      ;Move char in to R0 for put char
  773 0000032E F7FF FFC9       BL               PUTCHAR
  774 00000332 BC01            POP              {R0}
  775 00000334         
  776 00000334         ;Decrement number of characters left to read
  777 00000334 1E49            SUBS             R1, R1, #1
  778 00000336         ;Add to offset index for string
  779 00000336 1C40            ADDS             R0, R0, #1
  780 00000338         
  781 00000338 E7F4            B                READ_CHAR
  782 0000033A         



ARM Macro Assembler    Page 21 Exercise 09 Serial I/O Driver


  783 0000033A         END_PUT_STR
  784 0000033A         
  785 0000033A BD1E            POP              {R1,R2,R3,R4,PC} ;Restore original values
  786 0000033C         
  787 0000033C         ;Determines how many characters are in a a null terminated string
  788 0000033C         ;Memory of string starts in R0 and returns number of characters in R2
  789 0000033C         ;Prevents overrun of of buffer capacity specified in R1
  790 0000033C         ;
  791 0000033C         ;Input parameters:
  792 0000033C         ; R0 pointer to address of string 
  793 0000033C         ;Output parameters:
  794 0000033C         ;   R2: number of characters in String
  795 0000033C         ;Modified Registers
  796 0000033C         ;   None. The original contents of the registers are restored 
  797 0000033C         ;
  798 0000033C         
  799 0000033C         LengthStringSB
  800 0000033C B51B            PUSH             {R0, R1, R3, R4, LR}
  801 0000033E 214F            MOVS             R1, #MAX_STRING
  802 00000340 2200            MOVS             R2, #0      ; Initalize length to zero.
  803 00000342 2400            MOVS             R4, #0      ; Initalize STR offset to zero
  804 00000344         
  805 00000344         ADD_TO_LEN
  806 00000344         ;if legth is >= buffer, return
  807 00000344 428A            CMP              R2, R1
  808 00000346 DA05            BGE              END_GET_LEN
  809 00000348         ;Grab the next character of input and store in R3
  810 00000348 5D03            LDRB             R3, [R0, R4]
  811 0000034A         ;check if character is a null terminator
  812 0000034A 2B00            CMP              R3, #0
  813 0000034C D002            BEQ              END_GET_LEN
  814 0000034E         ;Add to string offset
  815 0000034E 1C64            ADDS             R4, R4, #1
  816 00000350         ;Add 1 to max
  817 00000350 1C52            ADDS             R2, R2, #1
  818 00000352 E7F7            B                ADD_TO_LEN
  819 00000354         END_GET_LEN
  820 00000354         ;Pop PC returns nested subroutine
  821 00000354 BD1B            POP              {R0, R1, R3, R4, PC}
  822 00000356         
  823 00000356         ;Stuff  
  824 00000356         DIVU



ARM Macro Assembler    Page 22 Exercise 09 Serial I/O Driver


  825 00000356 B404            PUSH             {R2}        ;store R2 Value
  826 00000358 2200            MOVS             R2,#0       ;move 0 to R2 for quotient
  827 0000035A 2800            CMP              R0,#0       ;Compare divisor to 0
  828 0000035C D010            BEQ              SETCARRY    ;if divisor = 0 go to SETCARRY
  829 0000035E         WHILE
  830 0000035E 4281            CMP              R1,R0       ;Compare R1 to R0
  831 00000360 D302            BLO              ENDWHILE    ;if dividend<Divisor End loop
  832 00000362 1C52            ADDS             R2,R2,#1    ;Add 1 to quotient
  833 00000364 1A09            SUBS             R1,R1,R0    ;Dividend - divisor
  834 00000366 E7FA            B                WHILE       ;branch to start of while  
  835 00000368         ENDWHILE
  836 00000368 0010            MOVS             R0,R2       ;move quotient to R0, so R0 remainder R1
  837 0000036A BC04            POP              {R2}        ;revert R2 to value before subroutine
  838 0000036C B403            PUSH             {R0,R1}     ;push R0 and R1
  839 0000036E F3EF 8000       MRS              R0,APSR     ;Set C flag to 0
  840 00000372 2120            MOVS             R1,#0x20    ;
  841 00000374 0609            LSLS             R1,#24      ;Shift 24 places (to most significant byte)
  842 00000376 4388            BICS             R0,R0,R1    ; 
  843 00000378 F380 8800       MSR              APSR,R0     ; 
  844 0000037C BC03            POP              {R0,R1}     ;revert R0 and R1 to answer 
  845 0000037E 4770            BX               LR          ;Go back to program
  846 00000380         SETCARRY
  847 00000380 BC04            POP              {R2}        ;Pop R2
  848 00000382 B403            PUSH             {R0,R1}     ;Store R0 and R1
  849 00000384 F3EF 8000       MRS              R0,APSR     ;Set C flag to 1
  850 00000388 2120            MOVS             R1,#0x20    ;
  851 0000038A 0609            LSLS             R1,#24      ;Shift 24 places (to most significant byte)
  852 0000038C 4308            ORRS             R0,R0,R1    ;
  853 0000038E F380 8800       MSR              APSR,R0     ;
  854 00000392 BC03            POP              {R0,R1}     ;Revert R0 and R1 to answer
  855 00000394 4770            BX               LR
  856 00000396         
  857 00000396         
  858 00000396         Init_UART0_IRQ
  859 00000396         ;Initalize UART0 for Serial Driver
  860 00000396         ;Allocate R0-2 for Ri=k 
  861 00000396         ;Store prevoius values for restoration
  862 00000396 B507            PUSH             {R0, R1, R2, LR}
  863 00000398         ;Initalize rxQueue
  864 00000398 4940            LDR              R1, =RxQueueRecord
  865 0000039A 4842            LDR              R0, =RxQueue
  866 0000039C 2204            MOVS             R2, #Q_BUF_SZ



ARM Macro Assembler    Page 23 Exercise 09 Serial I/O Driver


  867 0000039E F7FF FF33       BL               InitQueue
  868 000003A2 493D            LDR              R1, =TxQueueRecord
  869 000003A4 4840            LDR              R0, =TxQueue
  870 000003A6 2204            MOVS             R2, #Q_BUF_SZ
  871 000003A8 F7FF FF2E       BL               InitQueue
  872 000003AC         ;Select MCGPLLCLK / 2 as UART0 clock source
  873 000003AC 4849            LDR              R0,=SIM_SOPT2
  874 000003AE 494A            LDR              R1,=SIM_SOPT2_UART0SRC_MASK
  875 000003B0 6802            LDR              R2,[R0,#0]
  876 000003B2 438A            BICS             R2,R2,R1
  877 000003B4 4949            LDR              R1,=SIM_SOPT2_UART0_MCGPLLCLK_DIV2
  878 000003B6 430A            ORRS             R2,R2,R1
  879 000003B8 6002            STR              R2,[R0,#0]
  880 000003BA         ;Enable external connection for UART0
  881 000003BA 4849            LDR              R0,=SIM_SOPT5
  882 000003BC 4949            LDR              R1,= SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
  883 000003BE 6802            LDR              R2,[R0,#0]
  884 000003C0 438A            BICS             R2,R2,R1
  885 000003C2 6002            STR              R2,[R0,#0]
  886 000003C4         ;Enable clock for UART0 module
  887 000003C4 4848            LDR              R0,=SIM_SCGC4
  888 000003C6 4949            LDR              R1,= SIM_SCGC4_UART0_MASK
  889 000003C8 6802            LDR              R2,[R0,#0]
  890 000003CA 430A            ORRS             R2,R2,R1
  891 000003CC 6002            STR              R2,[R0,#0]
  892 000003CE         ;Enable clock for Port A module
  893 000003CE 4848            LDR              R0,=SIM_SCGC5
  894 000003D0 4948            LDR              R1,= SIM_SCGC5_PORTA_MASK
  895 000003D2 6802            LDR              R2,[R0,#0]
  896 000003D4 430A            ORRS             R2,R2,R1
  897 000003D6 6002            STR              R2,[R0,#0]
  898 000003D8         ;Connect PORT A Pin 1 (PTA1) to UART0 Rx (J1 Pin 02)
  899 000003D8 4847            LDR              R0,=PORTA_PCR1
  900 000003DA 4948            LDR              R1,=PORT_PCR_SET_PTA1_UART0_RX
  901 000003DC 6001            STR              R1,[R0,#0]
  902 000003DE         ;Connect PORT A Pin 2 (PTA2) to UART0 Tx (J1 Pin 04)
  903 000003DE 4848            LDR              R0,=PORTA_PCR2
  904 000003E0 4946            LDR              R1,=PORT_PCR_SET_PTA2_UART0_TX
  905 000003E2 6001            STR              R1,[R0,#0]
  906 000003E4         ;Disable UART0 receiver and transmitter
  907 000003E4 4831            LDR              R0,=UART0_BASE
  908 000003E6 210C            MOVS             R1,#UART0_C2_T_R



ARM Macro Assembler    Page 24 Exercise 09 Serial I/O Driver


  909 000003E8 78C2            LDRB             R2,[R0,#UART0_C2_OFFSET]
  910 000003EA 438A            BICS             R2,R2,R1
  911 000003EC 70C2            STRB             R2,[R0,#UART0_C2_OFFSET]
  912 000003EE         ;Init NVIC for UART0 Interrupts
  913 000003EE         ;Set UART0 IRQ Priority
  914 000003EE 4845            LDR              R0, =UART0_IPR
  915 000003F0 4945            LDR              R1, =NVIC_IPR_UART0_MASK
  916 000003F2 4A45            LDR              R2, =NVIC_IPR_UART0_PRI_3
  917 000003F4 6803            LDR              R3, [R0, #0]
  918 000003F6 438B            BICS             R3, R3, R1
  919 000003F8 4313            ORRS             R3, R3, R2
  920 000003FA 6003            STR              R3, [R0, #0]
  921 000003FC         ;Clear any pending UART0 Interrupts
  922 000003FC 4843            LDR              R0, =NVIC_ICPR
  923 000003FE 4944            LDR              R1, =NVIC_ICPR_UART0_MASK
  924 00000400 6001            STR              R1, [R0, #0]
  925 00000402         ;Unmask UART0 interrupts
  926 00000402 4844            LDR              R0, =NVIC_ISER
  927 00000404 4942            LDR              R1, =NVIC_ISER_UART0_MASK
  928 00000406 6001            STR              R1, [R0, #0]
  929 00000408         ;Init UART0 for 8N1 format at 9600 Baud,
  930 00000408         ;and enable the rx interrupt
  931 00000408 4828            LDR              R0, =UART0_BASE
  932 0000040A 2101            MOVS             R1,#UART0_BDH_9600
  933 0000040C 7001            STRB             R1,[R0,#UART0_BDH_OFFSET]
  934 0000040E 2138            MOVS             R1,#UART0_BDL_9600
  935 00000410 7041            STRB             R1,[R0,#UART0_BDL_OFFSET]
  936 00000412 2100            MOVS             R1,#UART0_C1_8N1
  937 00000414 7081            STRB             R1,[R0,#UART0_C1_OFFSET]
  938 00000416 2100            MOVS             R1,#UART0_C3_NO_TXINV
  939 00000418 7181            STRB             R1,[R0,#UART0_C3_OFFSET]
  940 0000041A 210F            MOVS             R1,#UART0_C4_NO_MATCH_OSR_16
  941 0000041C 7281            STRB             R1,[R0,#UART0_C4_OFFSET]
  942 0000041E 2100            MOVS             R1,#UART0_C5_NO_DMA_SSR_SYNC
  943 00000420 72C1            STRB             R1,[R0,#UART0_C5_OFFSET]
  944 00000422 211F            MOVS             R1,#UART0_S1_CLEAR_FLAGS
  945 00000424 7101            STRB             R1,[R0,#UART0_S1_OFFSET]
  947 00000426 21C0            MOVS             R1,               #UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
  948 00000428 7141            STRB             R1,[R0,#UART0_S2_OFFSET]
  949 0000042A         ;Enable UART0 Transmitter, reciever, and rx interrupt
  950 0000042A 212C            MOVS             R1,#UART0_C2_T_RI
  951 0000042C 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]



ARM Macro Assembler    Page 25 Exercise 09 Serial I/O Driver


  952 0000042E         ;Pop prevous R0-2 values off the stack.
  953 0000042E BD07            POP              {R0, R1, R2, PC}
  954 00000430         
  955 00000430         ;Prints the text in decimal of unsigned word value R0 in terminal screen
  956 00000430         ;Using DivU
  957 00000430         ;Input parameters:
  958 00000430         ;   R0 is an Unsigned Word Value to print
  959 00000430         ;Output parameters:
  960 00000430         ;   None
  961 00000430         ;Modified Registers
  962 00000430         ;   PSR: (after return, nothing else)
  963 00000430         PutNumU
  964 00000430 B403            PUSH             {R0,R1}     ;Push registers as to not overwrite original values
  965 00000432 0001            MOVS             R1,R0
  966 00000434 200A            MOVS             R0,#10      ;Initialize divisor
  967 00000436 F7FF FF8E       BL               DIVU        ;Divide binary value by 10, remainder (which is R1) is ASCii
                                                            
  968 0000043A 3030            ADDS             R0,R0,#48   ;Convert MSD to Ascii
  969 0000043C 2830            CMP              R0,#48
  970 0000043E D001            BEQ              NEXTDIGIT
  971 00000440 F7FF FF40       BL               PUTCHAR     ;Display on terminal, R1 is input for R1
  972 00000444         NEXTDIGIT
  973 00000444 3130            ADDS             R1,R1,#48   ;Convert LSD to ASCII
  974 00000446 0008            MOVS             R0,R1       ;Initialize PUTCHAR
  975 00000448 200D            MOVS             R0, #0x0D
  976 0000044A F7FF FF3B       BL               PUTCHAR
  977 0000044E 200A            MOVS             R0, #0x0A
  978 00000450 F7FF FF38       BL               PUTCHAR
  979 00000454 F7FF FF36       BL               PUTCHAR     ;Print last digit
  980 00000458 BC03            POP              {R0,R1}
  981 0000045A E5DB            B                MAIN
  982 0000045C         ;This subroutine moves the terminal to the next line
  983 0000045C         ;Input parameters:
  984 0000045C         ;   None
  985 0000045C         ;Output parameters:
  986 0000045C         ;   None
  987 0000045C         ;Modified Registers
  988 0000045C         ;   R0 is modefied to the carriqage return and the line feed characters but its
  989 0000045C         ;   original value is returned
  990 0000045C         NEXTLINE
  991 0000045C B501            PUSH             {R0,LR}     ;Dont fuck with R0
  992 0000045E 200D            MOVS             R0,#0x0D    ;Carriage Return



ARM Macro Assembler    Page 26 Exercise 09 Serial I/O Driver


  993 00000460 F7FF FF30       BL               PUTCHAR
  994 00000464 200A            MOVS             R0,#0x0A    ;Line feed
  995 00000466 F7FF FF2D       BL               PUTCHAR
  996 0000046A BD01            POP              {R0,PC}     ;Restore R0  
  997 0000046C         ;-------------------------------------------------------------------
  998 0000046C         
  999 0000046C         ;>>>>>   end subroutine code <<<<<
 1000 0000046C                 ALIGN
 1001 0000046C         ;****************************************************************
 1002 0000046C         ;Vector Table Mapped to Address 0 at Reset
 1003 0000046C         ;Linker requires __Vectors to be exported
 1004 0000046C 00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              4006A000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              40048004 
              0C000000 
              04010000 
              40048010 
              00010007 



ARM Macro Assembler    Page 27 Exercise 09 Serial I/O Driver


              40048034 
              00000400 
              40048038 
              00000200 
              40049004 
              01000200 
              40049008 
              E000E40C 
              000000C0 
              E000E280 
              00001000 
              E000E100         AREA             RESET, DATA, READONLY
 1005 00000000                 EXPORT           __Vectors
 1006 00000000                 EXPORT           __Vectors_End
 1007 00000000                 EXPORT           __Vectors_Size
 1008 00000000                 IMPORT           __initial_sp
 1009 00000000                 IMPORT           Dummy_Handler
 1010 00000000         __Vectors
 1011 00000000         ;ARM core vectors
 1012 00000000 00000000        DCD              __initial_sp ;00:end of stack
 1013 00000004 00000000        DCD              Reset_Handler ;01:reset vector
 1014 00000008 00000000        DCD              Dummy_Handler ;02:NMI
 1015 0000000C 00000000        DCD              Dummy_Handler ;03:hard fault
 1016 00000010 00000000        DCD              Dummy_Handler ;04:(reserved)
 1017 00000014 00000000        DCD              Dummy_Handler ;05:(reserved)
 1018 00000018 00000000        DCD              Dummy_Handler ;06:(reserved)
 1019 0000001C 00000000        DCD              Dummy_Handler ;07:(reserved)
 1020 00000020 00000000        DCD              Dummy_Handler ;08:(reserved)
 1021 00000024 00000000        DCD              Dummy_Handler ;09:(reserved)
 1022 00000028 00000000        DCD              Dummy_Handler ;10:(reserved)
 1023 0000002C 00000000        DCD              Dummy_Handler ;11:SVCall (supervisor call)
 1024 00000030 00000000        DCD              Dummy_Handler ;12:(reserved)
 1025 00000034 00000000        DCD              Dummy_Handler ;13:(reserved)
 1026 00000038 00000000        DCD              Dummy_Handler ;14:PendableSrvReq (pendable request 
 1027 0000003C         ;   for system service)
 1028 0000003C 00000000        DCD              Dummy_Handler ;15:SysTick (system tick timer)
 1029 00000040 00000000        DCD              Dummy_Handler ;16:DMA channel 0 xfer complete/error
 1030 00000044 00000000        DCD              Dummy_Handler ;17:DMA channel 1 xfer complete/error
 1031 00000048 00000000        DCD              Dummy_Handler ;18:DMA channel 2 xfer complete/error
 1032 0000004C 00000000        DCD              Dummy_Handler ;19:DMA channel 3 xfer complete/error
 1033 00000050 00000000        DCD              Dummy_Handler ;20:(reserved)
 1034 00000054 00000000        DCD              Dummy_Handler ;21:command complete; read collision



ARM Macro Assembler    Page 28 Exercise 09 Serial I/O Driver


 1035 00000058 00000000        DCD              Dummy_Handler ;22:low-voltage detect;
 1036 0000005C         ;   low-voltage warning
 1037 0000005C 00000000        DCD              Dummy_Handler ;23:low leakage wakeup
 1038 00000060 00000000        DCD              Dummy_Handler ;24:I2C0
 1039 00000064 00000000        DCD              Dummy_Handler ;25:I2C1
 1040 00000068 00000000        DCD              Dummy_Handler ;26:SPI0 (all IRQ sources)
 1041 0000006C 00000000        DCD              Dummy_Handler ;27:SPI1 (all IRQ sources)
 1042 00000070 00000000        DCD              UART0_ISR   ;28:UART0 (status; error)
 1043 00000074 00000000        DCD              Dummy_Handler ;29:UART1 (status; error)
 1044 00000078 00000000        DCD              Dummy_Handler ;30:UART2 (status; error)
 1045 0000007C 00000000        DCD              Dummy_Handler ;31:ADC0
 1046 00000080 00000000        DCD              Dummy_Handler ;32:CMP0
 1047 00000084 00000000        DCD              Dummy_Handler ;33:TPM0
 1048 00000088 00000000        DCD              Dummy_Handler ;34:TPM1
 1049 0000008C 00000000        DCD              Dummy_Handler ;35:TPM2
 1050 00000090 00000000        DCD              Dummy_Handler ;36:RTC (alarm)
 1051 00000094 00000000        DCD              Dummy_Handler ;37:RTC (seconds)
 1052 00000098 00000000        DCD              Dummy_Handler ;38:PIT (all IRQ sources)
 1053 0000009C 00000000        DCD              Dummy_Handler ;39:I2S0
 1054 000000A0 00000000        DCD              Dummy_Handler ;40:USB0
 1055 000000A4 00000000        DCD              Dummy_Handler ;41:DAC0
 1056 000000A8 00000000        DCD              Dummy_Handler ;42:TSI0
 1057 000000AC 00000000        DCD              Dummy_Handler ;43:MCG
 1058 000000B0 00000000        DCD              Dummy_Handler ;44:LPTMR0
 1059 000000B4 00000000        DCD              Dummy_Handler ;45:Segment LCD
 1060 000000B8 00000000        DCD              Dummy_Handler ;46:PORTA pin detect
 1061 000000BC 00000000        DCD              Dummy_Handler ;47:PORTC and PORTD pin detect
 1062 000000C0         __Vectors_End
 1063 000000C0 000000C0 
                       __Vectors_Size
                               EQU              __Vectors_End - __Vectors
 1064 000000C0                 ALIGN
 1065 000000C0         ;****************************************************************
 1066 000000C0         ;Constants
 1067 000000C0                 AREA             MyConst,DATA,READONLY
 1068 00000000         ;>>>>> begin constants here <<<<<
 1069 00000000 54 79 70 
              65 20 61 
              20 71 75 
              65 75 65 
              20 63 6F 
              6D 6D 61 



ARM Macro Assembler    Page 29 Exercise 09 Serial I/O Driver


              6E 64 20 
              28 64 2C 
              20 65 2C 
              20 68 2C 
              20 70 2C 
              20 73 29 
              3A 00    MainString
                               DCB              "Type a queue command (d, e, h, p, s):", 0
 1070 00000026 43 68 61 
              72 61 63 
              74 65 72 
              20 74 6F 
              20 65 6E 
              71 75 65 
              75 65 3A 
              20 00    eString DCB              "Character to enqueue: ", 0
 1071 0000003D 64 20 28 
              64 65 71 
              75 65 75 
              65 29 2C 
              20 65 20 
              28 65 6E 
              71 75 65 
              75 65 29 
              2C 20 68 
              20 28 68 
              65 6C 70 
              7D 2C 20 
              70 20 28 
              70 72 69 
              6E 74 29 
              2C 20 73 
              20 28 73 
              74 61 74 
              75 73 29 
              00       HelpString
                               DCB              "d (dequeue), e (enqueue), h (help}, p (print), s (status)", 0
 1072 00000077 53 75 63 
              63 65 73 
              73 3A 20 
              00       SuccessString
                               DCB              "Success: ", 0



ARM Macro Assembler    Page 30 Exercise 09 Serial I/O Driver


 1073 00000081 46 61 69 
              6C 75 72 
              65 3A 20 
              00       FailureString
                               DCB              "Failure: ", 0
 1074 0000008B 53 74 61 
              74 75 73 
              3A 20 00 Status  DCB              "Status: ", 0
 1075 00000094 49 6E 3D 
              30 78 20 
              00       InString
                               DCB              "In=0x ", 0
 1076 0000009B 4F 75 74 
              3D 30 78 
              20 00    OutString
                               DCB              "Out=0x ", 0
 1077 000000A3 4E 75 6D 
              3D 20 00 NumString
                               DCB              "Num= ", 0
 1078 000000A9 20 20 20 
              20 20 20 
              20 00    TabString
                               DCB              "       ", 0
 1079 000000B1 20 20 20 
              00       TabString2
                               DCB              "   ", 0
 1080 000000B5 53 74 61 
              74 75 73 
              3A 20 20 
              20 20 00 StatusString
                               DCB              "Status:    ", 0
 1081 000000C1         ;>>>>>   end constants here <<<<<
 1082 000000C1 00 00 00        ALIGN
 1083 000000C4         ;****************************************************************
 1084 000000C4         ;Variables
 1085 000000C4                 AREA             MyData,DATA,READWRITE
 1086 00000000         ;>>>>> begin variables here <<<<<
 1087 00000000         
 1088 00000000         ;Rx Queue
 1089 00000000         ;Memory allocated to store String input from user
 1090 00000000 00 00 00 
              00       RxQueue SPACE            Q_BUF_SZ



ARM Macro Assembler    Page 31 Exercise 09 Serial I/O Driver


 1091 00000004         ;6 Byte buffer to store queue information 
 1092 00000004 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 RxQueueRecord
                               SPACE            Q_REC_SZ
 1093 00000016         
 1094 00000016 00 00           ALIGN
 1095 00000018         
 1096 00000018         ;Tx Queue
 1097 00000018         ;Memory allocated to store String input from user
 1098 00000018 00 00 00 
              00       TxQueue SPACE            Q_BUF_SZ
 1099 0000001C         ;6 Byte buffer to store queue information 
 1100 0000001C 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 TxQueueRecord
                               SPACE            Q_REC_SZ
 1101 0000002E         
 1102 0000002E 00 00           ALIGN
 1103 00000030         
 1104 00000030         ;Memory allocated to store String input from user
 1105 00000030 00 00 00 
              00       Queue   SPACE            Q_BUF_SZ
 1106 00000034         ;6 Byte buffer to store queue information 
 1107 00000034 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 QueueRecord
                               SPACE            Q_REC_SZ
 1108 00000046         
 1109 00000046 00 00           ALIGN
 1110 00000048         
 1111 00000048 00 00   StringReversal
                               SPACE            2



ARM Macro Assembler    Page 32 Exercise 09 Serial I/O Driver


 1112 0000004A         
 1113 0000004A         ;>>>>>   end variables here <<<<<
 1114 0000004A 00 00           ALIGN
 1115 0000004C                 END
Command Line: --debug --length=49 --width=120 --diag_suppress=9931 --cpu=Cortex-M0+ --apcs=interwork --depend=.\objects\
exercise09.d -o.\objects\exercise09.o -ID:\Assembly\Exercise09\RTE -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.6.0\Dev
ice\Include -IC:\Keil_v5\ARM\CMSIS\Include --predefine="__UVISION_VERSION SETA 515" --predefine="MKL46Z256xxx4 SETA 1" -
-list=.\listings\exercise09.lst Exercise09.s
