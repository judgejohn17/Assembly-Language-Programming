


ARM Macro Assembler    Page 1 


    1 00000000         ;TTL Multiprecision Arithmetic with Mixed C and Assembly Languag Programming 
    2 00000000         ;****************************************************************
    3 00000000         ;Descriptive comment header goes here.
    4 00000000         ;This exercise investagates a KL46 program consisting of both C and assembly
    5 00000000         ;language components. The objective of this exercise is to perform multi-word number I/O 
    6 00000000         ;and addition. 
    7 00000000         ;Name:  John Judge
    8 00000000         ;Date: 4/28/16
    9 00000000         ;Class:  CMPE-250
   10 00000000         ;Section: Thursdays 2:00pm-3:50pm
   11 00000000         ;---------------------------------------------------------------
   12 00000000         ;Keil Template for KL46
   13 00000000         ;R. W. Melton
   14 00000000         ;April 3, 2015
   15 00000000         ;****************************************************************
   16 00000000         ;Assembler directives
   17 00000000                 THUMB
   19 00000000         ;****************************************************************
   20 00000000         ;Include files
   21 00000000                 GET              MKL46Z4.s   ;Included by start.s
   23 00000000         ;****************************************************************
   24 00000000         ;EQUates
   25 00000000         ;PORTx_PCRn (Port x pin control register n [for pin n])
   26 00000000         ;___->10-08:Pin mux control (select 0 to 8)
   27 00000000         ;Use provided PORT_PCR_MUX_SELECT_2_MASK
   28 00000000         ;---------------------------------------------------------------
   29 00000000         ;Port A
   31 00000000 01000200 
                       PORT_PCR_SET_PTA1_UART0_RX
                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   33 00000000 01000200 
                       PORT_PCR_SET_PTA2_UART0_TX
                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   34 00000000         ;---------------------------------------------------------------
   35 00000000         ;SIM_SCGC4
   36 00000000         ;1->10:UART0 clock gate control (enabled)
   37 00000000         ;Use provided SIM_SCGC4_UART0_MASK
   38 00000000         ;---------------------------------------------------------------
   39 00000000         ;SIM_SCGC5
   40 00000000         ;1->09:Port A clock gate control (enabled)



ARM Macro Assembler    Page 2 


   41 00000000         ;Use provided SIM_SCGC5_PORTA_MASK
   42 00000000         ;---------------------------------------------------------------
   43 00000000         ;SIM_SOPT2
   44 00000000         ;01=27-26:UART0SRC=UART0 clock source select
   45 00000000         ;         (PLLFLLSEL determines MCGFLLCLK' or MCGPLLCLK/2)
   46 00000000         ; 1=   16:PLLFLLSEL=PLL/FLL clock select (MCGPLLCLK/2)
   48 00000000 04000000 
                       SIM_SOPT2_UART0SRC_MCGPLLCLK
                               EQU              (1 << SIM_SOPT2_UART0SRC_SHIFT)
   50 00000000 04010000 
                       SIM_SOPT2_UART0_MCGPLLCLK_DIV2
                               EQU              (SIM_SOPT2_UART0SRC_MCGPLLCLK :OR: SIM_SOPT2_PLLFLLSEL_MASK)
   51 00000000         ;---------------------------------------------------------------
   52 00000000         ;SIM_SOPT5
   53 00000000         ; 0->   16:UART0 open drain enable (disabled)
   54 00000000         ; 0->   02:UART0 receive data select (UART0_RX)
   55 00000000         ;00->01-00:UART0 transmit data select source (UART0_TX)
   59 00000000 00010007 
                       SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
                               EQU              (SIM_SOPT5_UART0ODE_MASK :OR:                                  SIM_SOPT
5_UART0RXSRC_MASK :OR:                                  SIM_SOPT5_UART0TXSRC_MASK)
   60 00000000         ;---------------------------------------------------------------
   61 00000000         ;UART0_BDH
   62 00000000         ;    0->  7:LIN break detect IE (disabled)
   63 00000000         ;    0->  6:RxD input active edge IE (disabled)
   64 00000000         ;    0->  5:Stop bit number select (1)
   65 00000000         ;00001->4-0:SBR[12:0] (UART0CLK / [9600 * (OSR + 1)]) 
   66 00000000         ;UART0CLK is MCGPLLCLK/2
   67 00000000         ;MCGPLLCLK is 96 MHz
   68 00000000         ;MCGPLLCLK/2 is 48 MHz
   69 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   70 00000000 00000001 
                       UART0_BDH_9600
                               EQU              0x01
   71 00000000         ;---------------------------------------------------------------
   72 00000000         ;UART0_BDL
   73 00000000         ;26->7-0:SBR[7:0] (UART0CLK / [9600 * (OSR + 1)])
   74 00000000         ;UART0CLK is MCGPLLCLK/2
   75 00000000         ;MCGPLLCLK is 96 MHz
   76 00000000         ;MCGPLLCLK/2 is 48 MHz
   77 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   78 00000000 00000038 



ARM Macro Assembler    Page 3 


                       UART0_BDL_9600
                               EQU              0x38
   79 00000000         ;---------------------------------------------------------------
   80 00000000         ;UART0_C1
   81 00000000         ;0-->7:LOOPS=loops select (normal)
   82 00000000         ;0-->6:DOZEEN=doze enable (disabled)
   83 00000000         ;0-->5:RSRC=receiver source select (internal--no effect LOOPS=0)
   84 00000000         ;0-->4:M=9- or 8-bit mode select 
   85 00000000         ;        (1 start, 8 data [lsb first], 1 stop)
   86 00000000         ;0-->3:WAKE=receiver wakeup method select (idle)
   87 00000000         ;0-->2:IDLE=idle line type select (idle begins after start bit)
   88 00000000         ;0-->1:PE=parity enable (disabled)
   89 00000000         ;0-->0:PT=parity type (even parity--no effect PE=0)
   90 00000000 00000000 
                       UART0_C1_8N1
                               EQU              0x00
   91 00000000         ;---------------------------------------------------------------
   92 00000000         ;UART0_C2
   93 00000000         ;0-->7:TIE=transmit IE for TDRE (disabled)
   94 00000000         ;0-->6:TCIE=transmission complete IE for TC (disabled)
   95 00000000         ;0-->5:RIE=receiver IE for RDRF (disabled)
   96 00000000         ;0-->4:ILIE=idle line IE for IDLE (disabled)
   97 00000000         ;1-->3:TE=transmitter enable (enabled)
   98 00000000         ;1-->2:RE=receiver enable (enabled)
   99 00000000         ;0-->1:RWU=receiver wakeup control (normal)
  100 00000000         ;0-->0:SBK=send break (disabled, normal)
  101 00000000 0000000C 
                       UART0_C2_T_R
                               EQU              (UART0_C2_TE_MASK :OR: UART0_C2_RE_MASK)
  102 00000000 0000002C 
                       UART0_C2_T_RI
                               EQU              (UART0_C2_RIE_MASK :OR: UART0_C2_T_R)
  103 00000000 000000AC 
                       UART0_C2_TI_RI
                               EQU              (UART0_C2_TIE_MASK :OR: UART0_C2_T_RI)
  104 00000000         ;---------------------------------------------------------------
  105 00000000         ;UART0_C3
  106 00000000         ;0-->7:R8T9=9th data bit for receiver (not used M=0)
  107 00000000         ;           10th data bit for transmitter (not used M10=0)
  108 00000000         ;0-->6:R9T8=9th data bit for transmitter (not used M=0)
  109 00000000         ;           10th data bit for receiver (not used M10=0)
  110 00000000         ;0-->5:TXDIR=UART_TX pin direction in single-wire mode



ARM Macro Assembler    Page 4 


  111 00000000         ;            (no effect LOOPS=0)
  112 00000000         ;0-->4:TXINV=transmit data inversion (not inverted)
  113 00000000         ;0-->3:ORIE=overrun IE for OR (disabled)
  114 00000000         ;0-->2:NEIE=noise error IE for NF (disabled)
  115 00000000         ;0-->1:FEIE=framing error IE for FE (disabled)
  116 00000000         ;0-->0:PEIE=parity error IE for PF (disabled)
  117 00000000 00000000 
                       UART0_C3_NO_TXINV
                               EQU              0x00
  118 00000000         ;---------------------------------------------------------------
  119 00000000         ;UART0_C4
  120 00000000         ;    0-->  7:MAEN1=match address mode enable 1 (disabled)
  121 00000000         ;    0-->  6:MAEN2=match address mode enable 2 (disabled)
  122 00000000         ;    0-->  5:M10=10-bit mode select (not selected)
  123 00000000         ;01111-->4-0:OSR=over sampling ratio (16)
  124 00000000         ;               = 1 + OSR for 3 <= OSR <= 31
  125 00000000         ;               = 16 for 0 <= OSR <= 2 (invalid values)
  126 00000000 0000000F 
                       UART0_C4_OSR_16
                               EQU              0x0F
  127 00000000 0000000F 
                       UART0_C4_NO_MATCH_OSR_16
                               EQU              UART0_C4_OSR_16
  128 00000000         ;---------------------------------------------------------------
  129 00000000         ;UART0_C5
  130 00000000         ;  0-->  7:TDMAE=transmitter DMA enable (disabled)
  131 00000000         ;  0-->  6:Reserved; read-only; always 0
  132 00000000         ;  0-->  5:RDMAE=receiver full DMA enable (disabled)
  133 00000000         ;000-->4-2:Reserved; read-only; always 0
  134 00000000         ;  0-->  1:BOTHEDGE=both edge sampling (rising edge only)
  135 00000000         ;  0-->  0:RESYNCDIS=resynchronization disable (enabled)
  136 00000000 00000000 
                       UART0_C5_NO_DMA_SSR_SYNC
                               EQU              0x00
  137 00000000         ;---------------------------------------------------------------
  138 00000000         ;UART0_S1
  139 00000000         ;0-->7:TDRE=transmit data register empty flag; read-only
  140 00000000         ;0-->6:TC=transmission complete flag; read-only
  141 00000000         ;0-->5:RDRF=receive data register full flag; read-only
  142 00000000         ;1-->4:IDLE=idle line flag; write 1 to clear (clear)
  143 00000000         ;1-->3:OR=receiver overrun flag; write 1 to clear (clear)
  144 00000000         ;1-->2:NF=noise flag; write 1 to clear (clear)



ARM Macro Assembler    Page 5 


  145 00000000         ;1-->1:FE=framing error flag; write 1 to clear (clear)
  146 00000000         ;1-->0:PF=parity error flag; write 1 to clear (clear)
  147 00000000 0000001F 
                       UART0_S1_CLEAR_FLAGS
                               EQU              0x1F
  148 00000000         ;---------------------------------------------------------------
  149 00000000         ;UART0_S2
  150 00000000         ;1-->7:LBKDIF=LIN break detect interrupt flag (clear)
  151 00000000         ;             write 1 to clear
  152 00000000         ;1-->6:RXEDGIF=RxD pin active edge interrupt flag (clear)
  153 00000000         ;              write 1 to clear
  154 00000000         ;0-->5:(reserved); read-only; always 0
  155 00000000         ;0-->4:RXINV=receive data inversion (disabled)
  156 00000000         ;0-->3:RWUID=receive wake-up idle detect
  157 00000000         ;0-->2:BRK13=break character generation length (10)
  158 00000000         ;0-->1:LBKDE=LIN break detect enable (disabled)
  159 00000000         ;0-->0:RAF=receiver active flag; read-only
  160 00000000 000000C0 
                       UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
                               EQU              0xC0
  161 00000000         ;---------------------------------------------------------------
  162 00000000         ;---------------------------------------------------------------
  163 00000000         ;NVIC_ICER
  164 00000000         ;31-00:CLRENA=masks for HW IRQ sources;
  165 00000000         ;             read:   0 = unmasked;   1 = masked
  166 00000000         ;             write:  0 = no effect;  1 = mask
  167 00000000         ;22:PIT IRQ mask
  168 00000000         ;12:UART0 IRQ mask
  169 00000000 00400000 
                       NVIC_ICER_PIT_MASK
                               EQU              PIT_IRQ_MASK
  170 00000000 00001000 
                       NVIC_ICER_UART0_MASK
                               EQU              UART0_IRQ_MASK
  171 00000000         ;---------------------------------------------------------------
  172 00000000         ;NVIC_ICPR
  173 00000000         ;31-00:CLRPEND=pending status for HW IRQ sources;
  174 00000000         ;             read:   0 = not pending;  1 = pending
  175 00000000         ;             write:  0 = no effect;
  176 00000000         ;                     1 = change status to not pending
  177 00000000         ;22:PIT IRQ pending status
  178 00000000         ;12:UART0 IRQ pending status



ARM Macro Assembler    Page 6 


  179 00000000 00400000 
                       NVIC_ICPR_PIT_MASK
                               EQU              PIT_IRQ_MASK
  180 00000000 00001000 
                       NVIC_ICPR_UART0_MASK
                               EQU              UART0_IRQ_MASK
  181 00000000         ;---------------------------------------------------------------
  182 00000000         ;NVIC_IPR0-NVIC_IPR7
  183 00000000         ;2-bit priority:  00 = highest; 11 = lowest
  184 00000000         ;--PIT
  185 00000000 00000000 
                       PIT_IRQ_PRIORITY
                               EQU              0
  186 00000000 00C00000 
                       NVIC_IPR_PIT_MASK
                               EQU              (3 << PIT_PRI_POS)
  187 00000000 00000000 
                       NVIC_IPR_PIT_PRI_0
                               EQU              (PIT_IRQ_PRIORITY << UART0_PRI_POS)
  188 00000000         ;--UART0
  189 00000000 00000003 
                       UART0_IRQ_PRIORITY
                               EQU              3
  190 00000000 000000C0 
                       NVIC_IPR_UART0_MASK
                               EQU              (3 << UART0_PRI_POS)
  191 00000000 000000C0 
                       NVIC_IPR_UART0_PRI_3
                               EQU              (UART0_IRQ_PRIORITY << UART0_PRI_POS)
  192 00000000         ;---------------------------------------------------------------
  193 00000000         ;NVIC_ISER
  194 00000000         ;31-00:SETENA=masks for HW IRQ sources;
  195 00000000         ;             read:   0 = masked;     1 = unmasked
  196 00000000         ;             write:  0 = no effect;  1 = unmask
  197 00000000         ;22:PIT IRQ mask
  198 00000000         ;12:UART0 IRQ mask
  199 00000000 00400000 
                       NVIC_ISER_PIT_MASK
                               EQU              PIT_IRQ_MASK
  200 00000000 00001000 
                       NVIC_ISER_UART0_MASK
                               EQU              UART0_IRQ_MASK



ARM Macro Assembler    Page 7 


  201 00000000         ;---------------------------------------------------------------
  202 00000000         ;PIT_LDVALn:  PIT load value register n
  203 00000000         ;31-00:TSV=timer start value (period in clock cycles - 1)
  204 00000000         ;Clock ticks for 0.01 s at 24 MHz count rate
  205 00000000         ;0.01 s * 24,000,000 Hz = 240,000
  206 00000000         ;TSV = 240,000 - 1
  207 00000000 0003A97F 
                       PIT_LDVAL_10ms
                               EQU              239999
  208 00000000         ;---------------------------------------------------------------
  209 00000000         ;PIT_MCR:  PIT module control register
  210 00000000         ;1-->    0:FRZ=freeze (continue'/stop in debug mode)
  211 00000000         ;0-->    1:MDIS=module disable (PIT section)
  212 00000000         ;               RTI timer not affected
  213 00000000         ;               must be enabled before any other PIT setup
  214 00000000 00000001 
                       PIT_MCR_EN_FRZ
                               EQU              PIT_MCR_FRZ_MASK
  215 00000000         ;---------------------------------------------------------------
  216 00000000         ;PIT_TCTRLn:  PIT timer control register n
  217 00000000         ;0-->   2:CHN=chain mode (enable)
  218 00000000         ;1-->   1:TIE=timer interrupt enable
  219 00000000         ;1-->   0:TEN=timer enable
  220 00000000 00000003 
                       PIT_TCTRL_CH_IE
                               EQU              (PIT_TCTRL_TEN_MASK :OR: PIT_TCTRL_TIE_MASK)
  221 00000000         ;---------------------------------------------------------------
  222 00000000         ;Interrupt should be set to the highest priority
  223 00000000 00000000 
                       PIT_IRQ_PRI
                               EQU              0
  224 00000000         ;---------------------------------------------------
  225 00000000         
  226 00000000         ;Max length of queue
  227 00000000 00000004 
                       Q_BUF_SZ
                               EQU              4
  228 00000000 00000012 
                       Q_REC_SZ
                               EQU              18
  229 00000000         
  230 00000000         ;Max length of prompt string



ARM Macro Assembler    Page 8 


  231 00000000 0000004F 
                       MAX_STRING
                               EQU              79
  232 00000000 00000050 
                       MAX_QUEUE
                               EQU              80
  233 00000000 00000000 
                       IN_PTR  EQU              0
  234 00000000 00000004 
                       OUT_PTR EQU              4
  235 00000000 00000008 
                       BUF_START
                               EQU              8
  236 00000000 0000000C 
                       BUF_PAST
                               EQU              12
  237 00000000 00000010 
                       BUF_SIZE
                               EQU              16
  238 00000000 00000011 
                       NUM_ENQD
                               EQU              17
  239 00000000         
  240 00000000         ;****************************************************************
  241 00000000         ;Program
  242 00000000         ;Linker requires Reset_Handler
  243 00000000                 PRESERVE8
  244 00000000                 AREA             MyCode,CODE,READONLY
  245 00000000                 EXPORT           AddIntMultiU
  246 00000000                 EXPORT           GetStringSB
  247 00000000                 EXPORT           PutStringSB
  248 00000000                 EXPORT           Init_UART0_IRQ
  249 00000000         ;>>>>> begin subroutine code <<<<<
  250 00000000         ;This subroutine adds the n-word unsigned number in register R2 to 
  251 00000000         ;the n-word unsigned numbe rin register R1. The result
  252 00000000         ;is then stored in memory at address R0. The value located
  253 00000000         ;in R3 is the number of words of each number that will be added.
  254 00000000         ;R0 is then overwritten with either a 0 for success or the 
  255 00000000         ;value of 1 for failure (overflow)
  256 00000000         
  257 00000000         ;Load in values one word (register) at a time
  258 00000000         ;And add using ADCS to utilize the state of the ASPR c 



ARM Macro Assembler    Page 9 


  259 00000000         ;bit when carrying operations over.
  260 00000000         
  261 00000000         ;Inputs:
  262 00000000         ;R0 = mem address to store result added number
  263 00000000         ;R1 = mem address of number 1 to add
  264 00000000         ;R2 = mem address of number 2 to add
  265 00000000         ;R3 = size (number of words) that numbers in R1 and R2 coorespond to
  266 00000000         ;Outputs
  267 00000000         ;R0 = Status value (0 for success and 1 for overflow)
  268 00000000         AddIntMultiU
  269 00000000 B4FE            PUSH             {R1-R7}
  270 00000002 2500            MOVS             R5,#0       ;Initalize offset to 0
  271 00000004 2404            MOVS             R4,#4
  272 00000006 4363            MULS             R3,R4,R3    ;Multiply words by 4 to compare
  273 00000008 1C2D            ADDS             R5,R5,#0    ; clears c flag
  274 0000000A F3EF 8400       MRS              R4,APSR     ;Preserves APSR
  275 0000000E         AddIntMultiUloop
  276 0000000E 594E            LDR              R6,[R1,R5]  ;Load first number
  277 00000010 5957            LDR              R7,[R2,R5]  ;Load second number
  278 00000012 F384 8800       MSR              APSR,R4     ;Restore APSR
  279 00000016 417E            ADCS             R6,R6,R7
  280 00000018 5146            STR              R6,[R0,R5]  ;Store the result
  281 0000001A F3EF 8400       MRS              R4,APSR     ;Preserve APSR
  282 0000001E 1D2D            ADDS             R5,R5,#4    ;Increment Offset
  283 00000020 42AB            CMP              R3,R5
  284 00000022 D003            BEQ              EndAddIntMultiUloop
  285 00000024 E7F3            B                AddIntMultiUloop ;Continue adding
  286 00000026         
  287 00000026         CheckForOverflow
  288 00000026 2001            MOVS             R0,#1       ;Signal overlflow by settin R1
  289 00000028 BCFE            POP              {R1-R7}     ;Restore values
  290 0000002A 4770            BX               LR
  291 0000002C         
  292 0000002C         EndAddIntMultiUloop
  293 0000002C F384 8800       MSR              APSR,R4
  294 00000030 D2F9            BCS              CheckForOverflow ;If carry set then theres overflow
  295 00000032 2000            MOVS             R0,#0
  296 00000034 BCFE            POP              {R1-R7}     ;Restore values
  297 00000036 4770            BX               LR
  298 00000038         
  299 00000038         
  300 00000038         UART0_ISR



ARM Macro Assembler    Page 10 


  301 00000038         ;description: UART0 Interrupt Service routine. Checks what triggered ISR and acts accordingly.
  302 00000038         ;subroutines: Dequeue, Enqueue
  303 00000038         ;Input:   none
  304 00000038         ;Output:  none
  305 00000038         ;Modify:  none
  306 00000038 B672            CPSID            I           ; mask interrupts
  307 0000003A B500            PUSH             {LR}        ; preserve link register
  308 0000003C B430            PUSH             {R4,R5}     ; preserve registers
  309 0000003E 49A5            LDR              R1,=UART0_BASE ; base address
  310 00000040         ;Interrupt source can be found in UART0_S1
  311 00000040 78CC    checkTX LDRB             R4,[R1,#UART0_C2_OFFSET] ; loads current UART0 C2 settings
  312 00000042 2580            MOVS             R5,#UART0_C2_TIE_MASK ; Transmit Interrupt Enabled
  313 00000044 4025            ANDS             R5,R5,R4    ; turns off everything except pin 7, if it was on to begin w
                                                            ith
  314 00000046 D00D            BEQ              checkRX     ; if  pin 7 was off, TX interrupt is disabled
  315 00000048 790C            LDRB             R4,[R1,#UART0_S1_OFFSET] ; load S1 to check TDRE
  316 0000004A 2580            MOVS             R5,#UART0_S1_TDRE_MASK ; load tdre mask
  317 0000004C 402C            ANDS             R4,R4,R5
  318 0000004E D009            BEQ              checkRX     ; if not, check receive!
  319 00000050         ;otherwise, it is set! Let's dequeue character from TxQBuffer
  320 00000050 49A1            LDR              R1,=TxQueueRecord
  321 00000052 F000 F81B       BL               Dequeue
  322 00000056 D202            BCS              ISRtxfail   ; if the dequeue failed (BUFFER IS EMPTY), branch! otherwise
                                                            , run
  323 00000058         ; If it succeeded, write character to UART0 transmit data reg.
  324 00000058 499E            LDR              R1,=UART0_BASE ; base address
  325 0000005A 71C8            STRB             R0,[R1,#UART0_D_OFFSET] ; stores character from dequeue
  326 0000005C E002            B                checkRX     ; quit
  327 0000005E         ISRtxfail                            ; if TxQBuffer is empty, disable Tx
  328 0000005E 499D            LDR              R1,=UART0_BASE ; base address
  329 00000060 4C9E            LDR              R4,=UART0_C2_T_RI ; address of value to store
  330 00000062 70CC            STRB             R4,[R1,#UART0_C2_OFFSET] ; offset for transmit/recieve
  331 00000064 790C    checkRX LDRB             R4,[R1,#UART0_S1_OFFSET]
  332 00000066 2520            MOVS             R5,#UART0_S1_RDRF_MASK
  333 00000068 4025            ANDS             R5,R5,R4
  334 0000006A D003            BEQ              ISRend      ; if not, get out!
  335 0000006C         ; otherwise, let's enqueue this character
  336 0000006C 79C8            LDRB             R0,[R1,#UART0_D_OFFSET] ; gets character from data recieve register
  337 0000006E 499C            LDR              R1,=RxQueueRecord ; sets queue to enqueue into as RxQRecord
  338 00000070 F000 F82C       BL               Enqueue     ; enqueues the character from R0 into RxQRecord
  339 00000074         ; character is lost if RxQueue is full
  340 00000074 BC30    ISRend  POP              {R4,R5}     ; restore registers



ARM Macro Assembler    Page 11 


  341 00000076 B662            CPSIE            I           ; unmask interrupts
  342 00000078 BD00            POP              {PC}        ; return to where it was called from
  343 0000007A         
  344 0000007A         
  345 0000007A         
  346 0000007A         ;This subroutine initializes an empty queue
  347 0000007A         ;Input parameters:
  348 0000007A         ;   R0, queue buffer address 
  349 0000007A         ;   R1, queue record structure
  350 0000007A         ; R2, queue size
  351 0000007A         ;Output parameters:
  352 0000007A         ;   None 
  353 0000007A         ;Modified Registers
  354 0000007A         ; None 
  355 0000007A         InitQueue
  356 0000007A 6008            STR              R0,[R1,#IN_PTR] ;Initialize In pointer to start of queue
  357 0000007C 6048            STR              R0,[R1,#OUT_PTR] ;Initialize Out pointer to start of queue
  358 0000007E 6088            STR              R0,[R1,#BUF_START] ;Initialize buffer start to start of queue
  359 00000080 1880            ADDS             R0,R0,R2    ;Add buff start to queue size
  360 00000082 60C8            STR              R0,[R1,#BUF_PAST] ;store as buff past
  361 00000084 610A            STR              R2,[R1,#BUF_SIZE] ;Store queue size as buff size
  362 00000086 2000            MOVS             R0,#0       ;Initialize num enqd as zero
  363 00000088 7448            STRB             R0,[R1,#NUM_ENQD] ;store num enqd 
  364 0000008A 4770            BX               LR
  365 0000008C         ;This subroutine dequeues a character
  366 0000008C         ;Input paramters:
  367 0000008C         ; R1: Address of queue record structure
  368 0000008C         ;Output:
  369 0000008C         ; PSR C flag: success(0) or failure (1)
  370 0000008C         ; r0: Character to dequeued 
  371 0000008C         ;Modify: PSR
  372 0000008C         Dequeue
  373 0000008C B478            PUSH             {R3-R6}
  374 0000008E 7C4B            LDRB             R3,[R1,#NUM_ENQD] ;get number enqueued
  375 00000090 2B00            CMP              R3,#0       ;Compare num enqued and 0
  376 00000092 D011            BEQ              QueueEmpty  ;Branch if num enqd =< 0
  377 00000094 684D            LDR              R5,[R1,#OUT_PTR] ;get adress of outpointer
  378 00000096 68CE            LDR              R6,[R1,#BUF_PAST] ;Load buffer past
  379 00000098 7828            LDRB             R0,[R5,#0]  ;Load actual value from queue
  380 0000009A 1E5B            SUBS             R3,R3,#1    ;Decrement num enqd
  381 0000009C 744B            STRB             R3,[R1,#NUM_ENQD] ;Store new num enqd value
  382 0000009E 1C6D            ADDS             R5,R5,#1    ;Increment outpointer



ARM Macro Assembler    Page 12 


  383 000000A0 42B5            CMP              R5,R6       ;Compare to outpointer
  384 000000A2 D300            BLO              ClearPSRDequeue
  385 000000A4 688D            LDR              R5,[R1,#BUF_START] ;Load buffewr start
  386 000000A6         
  387 000000A6         ClearPSRDequeue
  388 000000A6 604D            STR              R5,[R1,#OUT_PTR] ;Store buffer start as outpointer
  389 000000A8 F3EF 8300       MRS              R3,APSR     ;Clear the PSR C flag
  390 000000AC 2420            MOVS             R4,#0x20
  391 000000AE 0624            LSLS             R4,R4,#24
  392 000000B0 43A3            BICS             R3,R3,R4
  393 000000B2 F383 8800       MSR              APSR,R3
  394 000000B6 E007            B                EndDequeue
  395 000000B8         QueueEmpty
  396 000000B8 F3EF 8300       MRS              R3,APSR     ;Set the PSR C flag
  397 000000BC 2420            MOVS             R4,#0x20
  398 000000BE 0624            LSLS             R4,R4,#24
  399 000000C0 4323            ORRS             R3,R3,R4
  400 000000C2 F383 8800       MSR              APSR, R3
  401 000000C6 E7FF            B                EndDequeue
  402 000000C8         EndDequeue
  403 000000C8 BC78            POP              {R3-R6}
  404 000000CA 4770            BX               LR
  405 000000CC         
  406 000000CC         ;This subroutine enqueues a character
  407 000000CC         ;Input paramters:
  408 000000CC         ; r0: Character to enque 
  409 000000CC         ; R1: Address of queue record structure
  410 000000CC         ;Output:
  411 000000CC         ; PSR C flag: success(0) or failure (1)
  412 000000CC         ;Modify: PSR
  413 000000CC         
  414 000000CC         ;This subroutine enqueues a character
  415 000000CC         ;Input paramters:
  416 000000CC         ; r0: Character to enque 
  417 000000CC         ; R1: Address of queue record structure
  418 000000CC         ;Output:
  419 000000CC         ; PSR C flag: success(0) or failure (1)
  420 000000CC         ;Modify: PSR
  421 000000CC         Enqueue
  422 000000CC B478            PUSH             {R3-R6}
  423 000000CE 7C4B            LDRB             R3,[R1, #NUM_ENQD] ;Load number enqued
  424 000000D0 7C0C            LDRB             R4,[R1, #BUF_SIZE] ;Load buffer size



ARM Macro Assembler    Page 13 


  425 000000D2 42A3            CMP              R3,R4       ;Compare
  426 000000D4 DA11            BGE              QueueFull   ;If number enqd >= buffsize then Queue full
  427 000000D6 680D            LDR              R5,[R1, #IN_PTR] ;Load inpointer
  428 000000D8 68CE            LDR              R6,[R1,#BUF_PAST] ;Load buffer past
  429 000000DA 7028            STRB             R0,[R5, #0] ;Store character at inpointer 
  430 000000DC 1C5B            ADDS             R3,R3,#1    ;Increment inpointer
  431 000000DE 744B            STRB             R3,[R1,#NUM_ENQD] ;Store num enqd
  432 000000E0 1C6D            ADDS             R5,R5,#1    ;Increment num enqd
  433 000000E2 42B5            CMP              R5,R6       ;If inpointer >= buff past
  434 000000E4 D300            BLO              SetCarry
  435 000000E6 688D            LDR              R5,[R1,#BUF_START] ;Load buff start
  436 000000E8         SetCarry
  437 000000E8 600D            STR              R5,[R1,#IN_PTR] ;Store buff start as inpointer
  438 000000EA F3EF 8300       MRS              R3,APSR     ;Clear the PSR C flag 
  439 000000EE 2420            MOVS             R4,#0x20
  440 000000F0 0624            LSLS             R4,R4,#24
  441 000000F2 43A3            BICS             R3,R3,R4
  442 000000F4 F383 8800       MSR              APSR,R3
  443 000000F8 E006            B                EndEnqueue
  444 000000FA         
  445 000000FA         QueueFull
  446 000000FA F3EF 8300       MRS              R3,APSR     ;Set PSR C flag to 1  
  447 000000FE 2420            MOVS             R4,#0x20
  448 00000100 0624            LSLS             R4,R4,#24
  449 00000102 4323            ORRS             R3,R3,R4
  450 00000104 F383 8800       MSR              APSR,R3
  451 00000108         
  452 00000108         EndEnqueue
  453 00000108 BC78            POP              {R3-R6}
  454 0000010A 4770            BX               LR
  455 0000010C         
  456 0000010C         ;This subroutine sends a character out of UART0 using interrupts
  457 0000010C         ;Inputs
  458 0000010C         ; R0 - Character to enqueue to TxQueue
  459 0000010C         ;Return 
  460 0000010C         ; None
  461 0000010C         
  462 0000010C         PutChar
  463 0000010C B506            PUSH             {R1,R2,LR}
  464 0000010E 4972            LDR              R1,=TxQueueRecord
  465 00000110         REPEAT_ENQ
  466 00000110         ;Mask all other interrupts



ARM Macro Assembler    Page 14 


  467 00000110 B672            CPSID            I
  468 00000112         ;Critical section -> enqueue character
  469 00000112         ;Enqueue character that's already in R0
  470 00000112 F7FF FFDB       BL               Enqueue
  471 00000116         ;Enable interrupts
  472 00000116 B662            CPSIE            I
  473 00000118 D2FA            BCS              REPEAT_ENQ
  474 0000011A         ;Enable UART0 Transmitter, reciever, and rx interrupt
  475 0000011A 496E            LDR              R1,=UART0_BASE
  476 0000011C 22AC            MOVS             R2,#UART0_C2_TI_RI
  477 0000011E 70CA            STRB             R2,[R1,#UART0_C2_OFFSET]
  478 00000120         ;Pop original register values off the stack
  479 00000120 BD06            POP              {R1,R2,PC}
  480 00000122         
  481 00000122         ;This subroutine receives a character from UART0 using interrupts
  482 00000122         ;Inputs 
  483 00000122         ; None
  484 00000122         ;Return
  485 00000122         ; R0 - Character dequeued from RxQueue
  486 00000122         GetChar
  487 00000122 B502            PUSH             {R1,LR}     ; Push varibles on the stack to avoid loss
  488 00000124 496E            LDR              R1,=RxQueueRecord
  489 00000126         REPEAT_DEQ
  490 00000126         ;Mask all interrupts
  491 00000126 B672            CPSID            I
  492 00000128         ;Critical code section - dequeue
  493 00000128 F7FF FFB0       BL               Dequeue
  494 0000012C         ;Re enable interrupts
  495 0000012C B662            CPSIE            I
  496 0000012E D2FA            BCS              REPEAT_DEQ
  497 00000130 BD02            POP              {R1,PC}
  498 00000132         
  499 00000132         
  500 00000132         ;The follwing subroutine reads a string of chars from the keyboard
  501 00000132         ;and stores them in a string dtarting from R0. For each character 
  502 00000132         ;up to R1-1 it echoes the character and when the carage character (13-10 0D-16)
  503 00000132         ;is not recieved it null terminates the string. it then moves
  504 00000132         ;the cursor to the begining of the next line
  505 00000132         ;Input parameters:
  506 00000132         ;   R1 one more than the oveflow buffer
  507 00000132         ; R0 pointer to address of string 
  508 00000132         ;Output parameters:



ARM Macro Assembler    Page 15 


  509 00000132         ;   None
  510 00000132         ;Modified Registers
  511 00000132         ;   None. The original contents of the registers are restored 
  512 00000132         ;                 
  513 00000132         GetStringSB
  514 00000132 B50F            PUSH             {R0,R1,R2,R3,LR}
  515 00000134 2200            MOVS             R2,#0       ;Initalize string offset to zero
  516 00000136 1E49            SUBS             R1,R1,#1
  517 00000138         GetStringSBLoop
  518 00000138 B401            PUSH             {R0}        ;Push Pointer value on stack
  519 0000013A F7FF FFF2       BL               GetChar     ;Get next char
  520 0000013E 0003            MOVS             R3,R0       ;Move char to r3
  521 00000140 BC01            POP              {R0}        ;Return pointer value to R0
  522 00000142 2B0D            CMP              R3,#13      ;Compare char to carrage return
  523 00000144 D00A            BEQ              EndGetStringSB
  524 00000146 2900            CMP              R1,#0       ;If there is no more character
  525 00000148 D0F6            BEQ              GetStringSBLoop
  526 0000014A B401            PUSH             {R0}        ;Save Pointer value on stack
  527 0000014C 0018            MOVS             R0,R3       ;move char to r3 for putchar
  528 0000014E F7FF FFDD       BL               PutChar
  529 00000152 BC01            POP              {R0}        ;Restore pointer value to R0
  530 00000154 5483            STRB             R3,[R0,R2]  ;Store char at pointer with offset
  531 00000156 1E49            SUBS             R1,R1,#1    ;Decrement number of chars
  532 00000158 1C52            ADDS             R2,R2,#1    ;Increment offset
  533 0000015A E7ED            B                GetStringSBLoop
  534 0000015C         EndGetStringSB
  535 0000015C         
  536 0000015C 2300            MOVS             R3,#0       ;null
  537 0000015E 5483            STRB             R3,[R0,R2]  ;null terminate
  538 00000160 BD0F            POP              {R0,R1,R2,R3,PC}
  539 00000162         
  540 00000162         
  541 00000162         ;Displays a null terminated string to the terminal screen from memory starting at R0 
  542 00000162         ;Preventing overun of the buffer capacity specified by R1
  543 00000162         ;Leaves cursor specified in R1
  544 00000162         
  545 00000162         PutStringSB
  546 00000162 B50F            PUSH             {R0-R3,LR}
  547 00000164         ;BL   LengthStringSB
  548 00000164         ;MOVS  R1,R2
  549 00000164         ReadChar
  550 00000164 2900            CMP              R1,#0       ;If string is empty



ARM Macro Assembler    Page 16 


  551 00000166 D00A            BEQ              EndPutStringSB
  552 00000168 7803            LDRB             R3,[R0,#0]  ;Put char in R3
  553 0000016A 2B00            CMP              R3,#0x00    ;Check if null
  554 0000016C D007            BEQ              EndPutStringSB ;End if null
  555 0000016E B401            PUSH             {R0}
  556 00000170 0018            MOVS             R0,R3
  557 00000172 F7FF FFCB       BL               PutChar
  558 00000176 BC01            POP              {R0}
  559 00000178 1E49            SUBS             R1,R1,#1    ;Decrement number of chars
  560 0000017A 1C40            ADDS             R0,R0,#1    ;Increment offset
  561 0000017C E7F2            B                ReadChar
  562 0000017E         EndPutStringSB
  563 0000017E BD0F            POP              {R0-R3,PC}
  564 00000180         
  565 00000180         ;Determines how many characters are in a a null terminated string
  566 00000180         ;Memory of string starts in R0 and returns number of characters in R2
  567 00000180         ;Prevents overrun of of buffer capacity specified in R1
  568 00000180         ;
  569 00000180         ;Input parameters:
  570 00000180         ; R0 pointer to address of string 
  571 00000180         ;Output parameters:
  572 00000180         ;   R1: number of characters in String
  573 00000180         ;Modified Registers
  574 00000180         ;   None. The original contents of the registers are restored 
  575 00000180         ;
  576 00000180         
  577 00000180         LengthStringSB
  578 00000180 B51D            PUSH             {R0,R2,R3,R4,LR}
  579 00000182 214F            MOVS             R1,#MAX_STRING
  580 00000184 2200            MOVS             R2,#0       ;Initalize length to 0
  581 00000186 2400            MOVS             R4,#0       ;Initalize offset to 0
  582 00000188         LengthStringSBLoop
  583 00000188 428A            CMP              R2,R1       ;Compare Max_String to 0
  584 0000018A DA05            BGE              EndLengthStringSB ;If Max_string < 0
  585 0000018C 5D03            LDRB             R3,[R0,R4]  ;Load first character in string
  586 0000018E 2B00            CMP              R3,#0       ;Compare char to 0
  587 00000190 D002            BEQ              EndLengthStringSB ;If null terminated then end
  588 00000192 1C64            ADDS             R4,R4,#1    ;Increment offset
  589 00000194 1C52            ADDS             R2,R2,#1    ;Increment lenghth 
  590 00000196 E7F7            B                LengthStringSBLoop
  591 00000198         EndLengthStringSB
  592 00000198 BD1D            POP              {R0,R2,R3,R4,PC}



ARM Macro Assembler    Page 17 


  593 0000019A         
  594 0000019A         ;Stuff  
  595 0000019A         DIVU
  596 0000019A B404            PUSH             {R2}        ;store R2 Value
  597 0000019C 2200            MOVS             R2,#0       ;move 0 to R2 for quotient
  598 0000019E 2800            CMP              R0,#0       ;Compare divisor to 0
  599 000001A0 D010            BEQ              SETCARRY    ;if divisor = 0 go to SETCARRY
  600 000001A2         WHILE
  601 000001A2 4281            CMP              R1,R0       ;Compare R1 to R0
  602 000001A4 D302            BLO              ENDWHILE    ;if dividend<Divisor End loop
  603 000001A6 1C52            ADDS             R2,R2,#1    ;Add 1 to quotient
  604 000001A8 1A09            SUBS             R1,R1,R0    ;Dividend - divisor
  605 000001AA E7FA            B                WHILE       ;branch to start of while  
  606 000001AC         ENDWHILE
  607 000001AC 0010            MOVS             R0,R2       ;move quotient to R0, so R0 remainder R1
  608 000001AE BC04            POP              {R2}        ;revert R2 to value before subroutine
  609 000001B0 B403            PUSH             {R0,R1}     ;push R0 and R1
  610 000001B2 F3EF 8000       MRS              R0,APSR     ;Set C flag to 0
  611 000001B6 2120            MOVS             R1,#0x20    ;
  612 000001B8 0609            LSLS             R1,#24      ;Shift 24 places (to most significant byte)
  613 000001BA 4388            BICS             R0,R0,R1    ; 
  614 000001BC F380 8800       MSR              APSR,R0     ; 
  615 000001C0 BC03            POP              {R0,R1}     ;revert R0 and R1 to answer 
  616 000001C2 4770            BX               LR          ;Go back to program
  617 000001C4         SETCARRY
  618 000001C4 BC04            POP              {R2}        ;Pop R2
  619 000001C6 B403            PUSH             {R0,R1}     ;Store R0 and R1
  620 000001C8 F3EF 8000       MRS              R0,APSR     ;Set C flag to 1
  621 000001CC 2120            MOVS             R1,#0x20    ;
  622 000001CE 0609            LSLS             R1,#24      ;Shift 24 places (to most significant byte)
  623 000001D0 4308            ORRS             R0,R0,R1    ;
  624 000001D2 F380 8800       MSR              APSR,R0     ;
  625 000001D6 BC03            POP              {R0,R1}     ;Revert R0 and R1 to answer
  626 000001D8 4770            BX               LR
  627 000001DA         
  628 000001DA         ;Prints the text in decimal of unsigned word value R0 in terminal screen
  629 000001DA         ;Using DivU
  630 000001DA         ;Input parameters:
  631 000001DA         ;   R0 is an Unsigned Word Value to print
  632 000001DA         ;Output parameters:
  633 000001DA         ;   None
  634 000001DA         ;Modified Registers



ARM Macro Assembler    Page 18 


  635 000001DA         ;   PSR: (after return, nothing else)
  636 000001DA         PutNumU
  637 000001DA B507            PUSH             {R0,R1,R2,LR} ;Push registers as to not overwrite original values
  638 000001DC 2200            MOVS             R2,#0       ;Initialize offset 
  639 000001DE         DivideNumber
  640 000001DE 280A            CMP              R0,#10      ;Compare to 10, Div U divides by 10
  641 000001E0 DB09            BLT              PutNumUComplete ;If its less than 10, stop dividing
  642 000001E2 0001            MOVS             R1,R0       ;Initialize divided into R1
  643 000001E4 200A            MOVS             R0,#10      ;Initialize divisor to 10
  644 000001E6 F7FF FFD8       BL               DIVU        ;Divide!
  645 000001EA B401            PUSH             {R0}        ;Save R0's value
  646 000001EC 483D            LDR              R0,=StringReversal ;Reverse! Reverse!
  647 000001EE 5481            STRB             R1,[R0,R2]  ;Store in reversed string
  648 000001F0 1C52            ADDS             R2,R2,#1    ;Increment offset
  649 000001F2 BC01            POP              {R0}
  650 000001F4 E7F3            B                DivideNumber ;Keep looping until number is less than 10  
  651 000001F6         PutNumUComplete
  652 000001F6 3030            ADDS             R0,R0,#'0'  ;Convert to ascii 
  653 000001F8 F7FF FF88       BL               PutChar     ;Print it 
  654 000001FC 1E52            SUBS             R2,R2,#1    ;Decrement offset  
  655 000001FE         PutNumUPrintChar
  656 000001FE 4839            LDR              R0,=StringReversal ;Initialize pointer  
  657 00000200 2A00            CMP              R2,#0       ;Compare to see if end is reached
  658 00000202 DB05            BLT              PutNumUEnd  ;If at end of string then end
  659 00000204 5C80            LDRB             R0,[R0,R2]  ;Get char
  660 00000206 3030            ADDS             R0,R0,#'0'  ;Turn to ascii
  661 00000208 F7FF FF80       BL               PutChar     ;Print
  662 0000020C 1E52            SUBS             R2,R2,#1    ;Decrement offset/counter
  663 0000020E E7F6            B                PutNumUPrintChar ;Loop 
  664 00000210         PutNumUEnd
  665 00000210 BD07            POP              {R0,R1,R2,PC}
  666 00000212         
  667 00000212         ;This subroutine prints  the hex representation of a value
  668 00000212         ;in r0 to the console
  669 00000212         ;Inputs:
  670 00000212         ; R0 - Value to print to the screen
  671 00000212         ;Outputs
  672 00000212         ; None
  673 00000212         PutNumHex
  674 00000212 B51C            PUSH             {R2,R3,R4,LR}
  675 00000214 2220            MOVS             R2,#32      ;Initialize counter
  676 00000216         PutNumHexLoop



ARM Macro Assembler    Page 19 


  677 00000216 2A00            CMP              R2,#0       ;Compare counter to 0
  678 00000218 DB10            BLT              EndPutNumHex
  679 0000021A 0003            MOVS             R3,R0       ;Move value tp r3
  680 0000021C 240F            MOVS             R4,#0x0F    ;Value to shift
  681 0000021E 40D3            LSRS             R3,R2       ;Shift to right most 
  682 00000220 401C            ANDS             R4,R4,R3    ;Mask 
  683 00000222 2C0A            CMP              R4,#10      ;Compare to ascii
  684 00000224 DA01            BGE              PrintLetter ;Its a letter        
  685 00000226 3430            ADDS             R4,#'0'     ;Its a number so print number
  686 00000228 E000            B                PrintNumber
  687 0000022A         PrintLetter
  688 0000022A 3437            ADDS             R4,R4,#55   ;Convert to ascii     
  689 0000022C         PrintNumber
  690 0000022C B401            PUSH             {R0}        ;Save R0 value
  691 0000022E 0020            MOVS             R0,R4       ;Initialize for put char
  692 00000230 F7FF FF6C       BL               PutChar
  693 00000234 BC01            POP              {R0}        ;Restore original value
  694 00000236         ;Reset value in R3 and increment loop counter
  695 00000236 2400            MOVS             R4,#0       ;Reset R4
  696 00000238 1F12            SUBS             R2,R2,#4    ;Decrement counter
  697 0000023A E7EC            B                PutNumHexLoop
  698 0000023C         EndPutNumHex
  699 0000023C BD1C            POP              {R2,R3,R4,PC}
  700 0000023E         
  701 0000023E         
  702 0000023E         Init_UART0_IRQ
  703 0000023E         ;Initalize UART0 for Serial Driver
  704 0000023E         ;Allocate R0-2 for Ri=k 
  705 0000023E         ;Store prevoius values for restoration
  706 0000023E B50F            PUSH             {R0, R1, R2, R3, LR}
  707 00000240         ;Initalize rxQueue
  708 00000240 4927            LDR              R1, =RxQueueRecord
  709 00000242 4829            LDR              R0, =RxQueue
  710 00000244 2204            MOVS             R2, #Q_BUF_SZ
  711 00000246 F7FF FF18       BL               InitQueue
  712 0000024A 4923            LDR              R1, =TxQueueRecord
  713 0000024C 4827            LDR              R0, =TxQueue
  714 0000024E 2204            MOVS             R2, #Q_BUF_SZ
  715 00000250 F7FF FF13       BL               InitQueue
  716 00000254         ;Select MCGPLLCLK / 2 as UART0 clock source
  717 00000254 482B            LDR              R0,=SIM_SOPT2
  718 00000256 492C            LDR              R1,=SIM_SOPT2_UART0SRC_MASK



ARM Macro Assembler    Page 20 


  719 00000258 6802            LDR              R2,[R0,#0]
  720 0000025A 438A            BICS             R2,R2,R1
  721 0000025C 492B            LDR              R1,=SIM_SOPT2_UART0_MCGPLLCLK_DIV2
  722 0000025E 430A            ORRS             R2,R2,R1
  723 00000260 6002            STR              R2,[R0,#0]
  724 00000262         ;Enable external connection for UART0
  725 00000262 482B            LDR              R0,=SIM_SOPT5
  726 00000264 492B            LDR              R1,=SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
  727 00000266 6802            LDR              R2,[R0,#0]
  728 00000268 438A            BICS             R2,R2,R1
  729 0000026A 6002            STR              R2,[R0,#0]
  730 0000026C         ;Enable clock for UART0 module 
  731 0000026C 482A            LDR              R0,=SIM_SCGC4
  732 0000026E 492B            LDR              R1,=SIM_SCGC4_UART0_MASK
  733 00000270 6802            LDR              R2,[R0,#0]
  734 00000272 430A            ORRS             R2,R2,R1
  735 00000274 6002            STR              R2,[R0,#0]
  736 00000276         ;Enable clock for Port A module
  737 00000276 482A            LDR              R0,=SIM_SCGC5
  738 00000278 492A            LDR              R1,=SIM_SCGC5_PORTA_MASK
  739 0000027A 6802            LDR              R2,[R0,#0]
  740 0000027C 430A            ORRS             R2,R2,R1
  741 0000027E 6002            STR              R2,[R0,#0]
  742 00000280         ;Connect PORT A Pin 1 (PTA1) to UART0 Rx (J1 Pin 02)
  743 00000280 4829            LDR              R0,=PORTA_PCR1
  744 00000282 492A            LDR              R1,=PORT_PCR_SET_PTA1_UART0_RX
  745 00000284 6001            STR              R1,[R0,#0]
  746 00000286         ;Connect PORT A Pin 2 (PTA2) to UART0 Tx (J1 Pin 04)
  747 00000286 482A            LDR              R0,=PORTA_PCR2
  748 00000288 4928            LDR              R1,=PORT_PCR_SET_PTA2_UART0_TX
  749 0000028A 6001            STR              R1,[R0,#0]
  750 0000028C         ;Disable UART0 receiver and transmitter
  751 0000028C 4811            LDR              R0,=UART0_BASE
  752 0000028E 210C            MOVS             R1,#UART0_C2_T_R
  753 00000290 78C2            LDRB             R2,[R0,#UART0_C2_OFFSET]
  754 00000292 438A            BICS             R2,R2,R1
  755 00000294 70C2            STRB             R2,[R0,#UART0_C2_OFFSET]
  756 00000296         ;set UART0 IRQ priority
  757 00000296 4827            LDR              R0,=UART0_IPR
  758 00000298         ;LDR R1,=NVIC_IPR_UART0_MASK
  759 00000298 4A27            LDR              R2,=NVIC_IPR_UART0_PRI_3
  760 0000029A 6803            LDR              R3,[R0,#0]



ARM Macro Assembler    Page 21 


  761 0000029C         ;BICS R3,R3,R1
  762 0000029C 4313            ORRS             R3,R3,R2
  763 0000029E 6003            STR              R3,[R0,#0]
  764 000002A0         ;clear any pending UART0 interrupts
  765 000002A0 4826            LDR              R0,=NVIC_ICPR
  766 000002A2 4927            LDR              R1,=NVIC_ICPR_UART0_MASK
  767 000002A4 6001            STR              R1,[R0,#0]
  768 000002A6         ;Unmask UART0 interrupts
  769 000002A6 4827            LDR              R0,=NVIC_ISER
  770 000002A8 4925            LDR              R1,=NVIC_ISER_UART0_MASK
  771 000002AA 6001            STR              R1,[R0,#0]
  772 000002AC         ;Set UART0 for 9600 baud, 8N1 protocol
  773 000002AC 4809            LDR              R0,=UART0_BASE
  774 000002AE 2101            MOVS             R1,#UART0_BDH_9600
  775 000002B0 7001            STRB             R1,[R0,#UART0_BDH_OFFSET]
  776 000002B2 2138            MOVS             R1,#UART0_BDL_9600
  777 000002B4 7041            STRB             R1,[R0,#UART0_BDL_OFFSET]
  778 000002B6 2100            MOVS             R1,#UART0_C1_8N1
  779 000002B8 7081            STRB             R1,[R0,#UART0_C1_OFFSET]
  780 000002BA 2100            MOVS             R1,#UART0_C3_NO_TXINV
  781 000002BC 7181            STRB             R1,[R0,#UART0_C3_OFFSET]
  782 000002BE 210F            MOVS             R1,#UART0_C4_NO_MATCH_OSR_16
  783 000002C0 7281            STRB             R1,[R0,#UART0_C4_OFFSET]
  784 000002C2 2100            MOVS             R1,#UART0_C5_NO_DMA_SSR_SYNC
  785 000002C4 72C1            STRB             R1,[R0,#UART0_C5_OFFSET]
  786 000002C6 211F            MOVS             R1,#UART0_S1_CLEAR_FLAGS
  787 000002C8 7101            STRB             R1,[R0,#UART0_S1_OFFSET]
  788 000002CA 21C0            MOVS             R1,#UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
  789 000002CC 7141            STRB             R1,[R0,#UART0_S2_OFFSET]
  790 000002CE         ;Enable UART0 receiver and transmitter
  791 000002CE 212C            MOVS             R1,#UART0_C2_T_RI
  792 000002D0 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  793 000002D2         ;Pop prevous R0-2 values off the stack.
  794 000002D2 BD0F            POP              {R0, R1, R2, R3, PC}
  795 000002D4         
  796 000002D4         ;>>>>>   end subroutine code <<<<<
  797 000002D4                 ALIGN
  798 000002D4         ;****************************************************************
  799 000002D4         ;Vector Table Mapped to Address 0 at Reset
  800 000002D4         ;Linker requires __Vectors to be exported
  801 000002D4 4006A000 
              00000000 



ARM Macro Assembler    Page 22 


              0000002C 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              40048004 
              0C000000 
              04010000 
              40048010 
              00010007 
              40048034 
              00000400 
              40048038 
              00000200 
              40049004 
              01000200 
              40049008 
              E000E40C 
              000000C0 
              E000E280 
              00001000 
              E000E100         AREA             RESET, DATA, READONLY
  802 00000000                 IMPORT           Reset_Handler
  803 00000000                 EXPORT           __Vectors
  804 00000000                 EXPORT           __Vectors_End
  805 00000000                 EXPORT           __Vectors_Size
  806 00000000                 IMPORT           __initial_sp
  807 00000000                 IMPORT           Dummy_Handler
  808 00000000         __Vectors
  809 00000000         ;ARM core vectors
  810 00000000 00000000        DCD              __initial_sp ;00:end of stack
  811 00000004 00000000        DCD              Reset_Handler ;01:reset vector
  812 00000008 00000000        DCD              Dummy_Handler ;02:NMI
  813 0000000C 00000000        DCD              Dummy_Handler ;03:hard fault
  814 00000010 00000000        DCD              Dummy_Handler ;04:(reserved)
  815 00000014 00000000        DCD              Dummy_Handler ;05:(reserved)
  816 00000018 00000000        DCD              Dummy_Handler ;06:(reserved)



ARM Macro Assembler    Page 23 


  817 0000001C 00000000        DCD              Dummy_Handler ;07:(reserved)
  818 00000020 00000000        DCD              Dummy_Handler ;08:(reserved)
  819 00000024 00000000        DCD              Dummy_Handler ;09:(reserved)
  820 00000028 00000000        DCD              Dummy_Handler ;10:(reserved)
  821 0000002C 00000000        DCD              Dummy_Handler ;11:SVCall (supervisor call)
  822 00000030 00000000        DCD              Dummy_Handler ;12:(reserved)
  823 00000034 00000000        DCD              Dummy_Handler ;13:(reserved)
  824 00000038 00000000        DCD              Dummy_Handler ;14:PendableSrvReq (pendable request 
  825 0000003C         ;   for system service)
  826 0000003C 00000000        DCD              Dummy_Handler ;15:SysTick (system tick timer)
  827 00000040 00000000        DCD              Dummy_Handler ;16:DMA channel 0 xfer complete/error
  828 00000044 00000000        DCD              Dummy_Handler ;17:DMA channel 1 xfer complete/error
  829 00000048 00000000        DCD              Dummy_Handler ;18:DMA channel 2 xfer complete/error
  830 0000004C 00000000        DCD              Dummy_Handler ;19:DMA channel 3 xfer complete/error
  831 00000050 00000000        DCD              Dummy_Handler ;20:(reserved)
  832 00000054 00000000        DCD              Dummy_Handler ;21:command complete; read collision
  833 00000058 00000000        DCD              Dummy_Handler ;22:low-voltage detect;
  834 0000005C         ;   low-voltage warning
  835 0000005C 00000000        DCD              Dummy_Handler ;23:low leakage wakeup
  836 00000060 00000000        DCD              Dummy_Handler ;24:I2C0
  837 00000064 00000000        DCD              Dummy_Handler ;25:I2C1
  838 00000068 00000000        DCD              Dummy_Handler ;26:SPI0 (all IRQ sources)
  839 0000006C 00000000        DCD              Dummy_Handler ;27:SPI1 (all IRQ sources)
  840 00000070 00000000        DCD              UART0_ISR   ;28:UART0 (status; error)
  841 00000074 00000000        DCD              Dummy_Handler ;29:UART1 (status; error)
  842 00000078 00000000        DCD              Dummy_Handler ;30:UART2 (status; error)
  843 0000007C 00000000        DCD              Dummy_Handler ;31:ADC0
  844 00000080 00000000        DCD              Dummy_Handler ;32:CMP0
  845 00000084 00000000        DCD              Dummy_Handler ;33:TPM0
  846 00000088 00000000        DCD              Dummy_Handler ;34:TPM1
  847 0000008C 00000000        DCD              Dummy_Handler ;35:TPM2
  848 00000090 00000000        DCD              Dummy_Handler ;36:RTC (alarm)
  849 00000094 00000000        DCD              Dummy_Handler ;37:RTC (seconds)
  850 00000098 00000000        DCD              Dummy_Handler ;38:PIT (all IRQ sources)
  851 0000009C 00000000        DCD              Dummy_Handler ;39:I2S0
  852 000000A0 00000000        DCD              Dummy_Handler ;40:USB0
  853 000000A4 00000000        DCD              Dummy_Handler ;41:DAC0
  854 000000A8 00000000        DCD              Dummy_Handler ;42:TSI0
  855 000000AC 00000000        DCD              Dummy_Handler ;43:MCG
  856 000000B0 00000000        DCD              Dummy_Handler ;44:LPTMR0
  857 000000B4 00000000        DCD              Dummy_Handler ;45:Segment LCD
  858 000000B8 00000000        DCD              Dummy_Handler ;46:PORTA pin detect



ARM Macro Assembler    Page 24 


  859 000000BC 00000000        DCD              Dummy_Handler ;47:PORTC and PORTD pin detect
  860 000000C0         __Vectors_End
  861 000000C0 000000C0 
                       __Vectors_Size
                               EQU              __Vectors_End - __Vectors
  862 000000C0                 ALIGN
  863 000000C0         ;****************************************************************
  864 000000C0         ;Constants
  865 000000C0                 AREA             MyConst,DATA,READONLY
  866 00000000         ;>>>>> begin constants here <<<<<
  867 00000000         
  868 00000000         ;>>>>>   end constants here <<<<<
  869 00000000                 ALIGN
  870 00000000         ;****************************************************************
  871 00000000         ;Variables
  872 00000000                 AREA             MyData,DATA,READWRITE
  873 00000000         ;>>>>> begin variables here <<<<<
  874 00000000         ;Rx Queue
  875 00000000 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 



ARM Macro Assembler    Page 25 


              00 00 00 
              00 00 00 
              00 00    RxQueue SPACE            MAX_QUEUE
  876 00000050 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 RxQueueRecord
                               SPACE            Q_REC_SZ
  877 00000062         
  878 00000062 00 00           ALIGN
  879 00000064         ;Tx Queue
  880 00000064 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00    TxQueue SPACE            MAX_QUEUE
  881 000000B4 00 00 00 
              00 00 00 



ARM Macro Assembler    Page 26 


              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 TxQueueRecord
                               SPACE            Q_REC_SZ
  882 000000C6 00 00           ALIGN
  883 000000C8         ;Queue 
  884 000000C8 00 00 00 
              00       Queue   SPACE            Q_BUF_SZ
  885 000000CC 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 QueueRecord
                               SPACE            Q_REC_SZ
  886 000000DE 00 00           ALIGN
  887 000000E0 00 00   StringReversal
                               SPACE            2
  888 000000E2 00 00           ALIGN
  889 000000E4 00 00   APSRState
                               SPACE            2
  890 000000E6 00 00           ALIGN
  891 000000E8 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 



ARM Macro Assembler    Page 27 


              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00       InputString
                               SPACE            MAX_STRING
  892 00000137 00              ALIGN
  893 00000138         ;>>>>>   end variables here <<<<<
  894 00000138                 ALIGN
  895 00000138                 END
Command Line: --debug --length=49 --width=120 --diag_suppress=9931 --cpu=Cortex-M0+ --apcs=interwork --depend=.\objects\
exercise11.d -o.\objects\exercise11.o -ID:\Assembly\RTE -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.6.0\Device\Include
 -IC:\Keil_v5\ARM\CMSIS\Include --predefine="__UVISION_VERSION SETA 515" --predefine="MKL46Z256xxx4 SETA 1" --list=.\lis
tings\exercise11.lst Exercise11.s
